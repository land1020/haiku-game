<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>性癖俳句ロワイヤル - Online</title>
    <!-- Vue.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.4.19/vue.global.prod.min.js"></script>
    <!-- フォント -->
    <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* --- デザイン定義 --- */
        :root {
            --bg-color: #fcfaf2;
            --text-color: #3e3a39;
            --accent-color: #b93a32;
            --oni-color: #800080;
            --sub-color: #2a3a55;
            --gold-color: #c5a059;
            --free-color: #2e8b57;
            --fav-color: #ff8c00;
        }

        body {
            font-family: 'Shippori Mincho', serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            background-image: radial-gradient(#e6e2d3 1px, transparent 1px);
            background-size: 20px 20px;
            padding-bottom: 50px;
        }

        [v-cloak] {
            display: none;
        }

        .app-container {
            max-width: 600px;
            margin: 0 auto;
            min-height: 100vh;
            padding: 10px;
            box-sizing: border-box;
        }

        h1,
        h2,
        h3 {
            text-align: center;
            margin-bottom: 0.5em;
        }

        .logo {
            font-size: 1.8rem;
            border-bottom: 3px double var(--accent-color);
            display: inline-block;
            margin-bottom: 15px;
            margin-top: 10px;
        }

        .card-box {
            background: #fff;
            border: 1px solid #dcdcdc;
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }

        /* 順位表エリア */
        .scoreboard {
            font-size: 0.85rem;
            background: #fdfdfd;
            border: 1px solid #eee;
            padding: 10px;
            margin-bottom: 15px;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px dotted #ccc;
            padding: 6px 0;
        }

        .master-badge {
            font-size: 0.7rem;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 5px;
        }

        .master-done {
            background: #ddd;
            color: #555;
        }

        .master-yet {
            background: var(--accent-color);
            color: white;
        }

        .heart-count {
            color: #e91e63;
            font-weight: bold;
            margin-right: 8px;
            font-size: 0.9rem;
        }

        .btn {
            background-color: var(--sub-color);
            color: #fff;
            border: none;
            padding: 10px;
            font-family: 'Shippori Mincho', serif;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 4px;
            width: 100%;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(2px);
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: var(--accent-color);
            font-weight: bold;
        }

        .btn-danger {
            background-color: #d9534f;
            font-size: 0.9rem;
            padding: 8px;
            border-radius: 4px;
            border: none;
            color: white;
            cursor: pointer;
        }

        .btn-add {
            background-color: var(--free-color);
            width: auto;
            padding: 5px 15px;
            font-size: 0.9rem;
        }

        /* 俳句作成エリア */
        .haiku-preview {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
            background: #eee;
            padding: 15px;
            border-radius: 8px;
            align-items: center;
        }

        .haiku-slot {
            width: 100%;
            padding: 10px;
            background: #fff;
            border: 2px dashed #aaa;
            text-align: center;
            font-size: 1.1rem;
            cursor: pointer;
            border-radius: 4px;
            min-height: 1.5em;
        }

        .haiku-slot.filled {
            border: 2px solid var(--sub-color);
            background: #f0f8ff;
            font-weight: bold;
        }

        .haiku-slot.filled.oni {
            border: 2px solid var(--oni-color);
            background: #f3e6f3;
            color: var(--oni-color);
        }

        .haiku-slot.filled.free {
            border: 2px solid var(--free-color);
            background: #f0fff0;
            color: #006400;
        }

        /* 自由記入エリア */
        .free-input-area {
            background: #f9f9f9;
            padding: 10px;
            border: 1px dashed #ccc;
            margin-bottom: 15px;
            border-radius: 4px;
        }

        .radio-group {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .input-row {
            display: flex;
            gap: 5px;
        }

        /* 手札エリア */
        .hand-section {
            margin-top: 10px;
        }

        .hand-label {
            font-size: 0.9rem;
            font-weight: bold;
            color: #666;
            margin-bottom: 5px;
        }

        .card-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-start;
        }

        .word-card {
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
            font-size: 0.9rem;
            position: relative;
            text-align: center;
            flex-grow: 0;
            flex-shrink: 0;
        }

        .word-card.oni {
            border-color: var(--oni-color);
            color: var(--oni-color);
            background: #fffafa;
            font-weight: bold;
        }

        .word-card.free {
            border-color: var(--free-color);
            color: #006400;
        }

        .word-card.selected {
            background: #ccc;
            color: #fff;
            pointer-events: none;
        }

        .point-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            background: var(--sub-color);
            color: #fff;
            font-size: 0.65rem;
            padding: 2px 4px;
            border-radius: 4px;
            z-index: 1;
        }

        .word-card.oni .point-badge {
            background: var(--oni-color);
        }

        .word-card.free .point-badge {
            background: var(--free-color);
        }

        /* 短冊リスト */
        .tanzaku {
            background: #fff;
            padding: 10px 15px;
            border-left: 5px solid var(--sub-color);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            margin-bottom: 10px;
        }

        .rank-badge {
            padding: 2px 8px;
            color: white;
            font-size: 0.8rem;
            border-radius: 4px;
            margin-right: 5px;
        }

        .error-msg {
            color: var(--accent-color);
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }

        .win-badge {
            display: inline-flex;
            align-items: center;
            background: #fff8dc;
            border: 1px solid #ffd700;
            border-radius: 20px;
            padding: 2px 8px;
            margin-left: 5px;
            font-size: 0.85rem;
            color: #d2691e;
            font-weight: bold;
        }

        .win-icon {
            width: 20px;
            height: 20px;
            margin-right: 4px;
            vertical-align: middle;
        }

        /* --- デバッグ用 --- */
        /* --- 俳句演出アニメーション --- */
        .special-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .special-bg {
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, gold 0%, transparent 10%);
            background-size: 20px 20px;
            opacity: 0.2;
            animation: stars 10s linear infinite;
        }

        .special-content {
            position: relative;
            text-align: center;
            color: #fff;
            font-family: 'Shippori Mincho', serif;
        }

        .special-text {
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 10px gold, 0 0 20px orangered;
            /* writing-mode: vertical-rl; */
            /* text-orientation: upright; */
            height: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1.5rem;
            margin: 0 auto;
            padding: 50px 0;
        }

        .phrase {
            opacity: 0;
            transform: scale(3);
            animation: stamp-in 0.5s forwards;
        }

        .phrase.top {
            animation-delay: 0.5s;
        }

        .phrase.middle {
            animation-delay: 1.5s;
        }

        .phrase.bottom {
            animation-delay: 2.5s;
        }

        .special-footer {
            position: absolute;
            bottom: -50px;
            left: 0;
            right: 0;
            font-size: 1.5rem;
            color: gold;
            opacity: 0;
            animation: fade-up 1s forwards 3.5s;
        }

        @keyframes stamp-in {
            0% {
                opacity: 0;
                transform: scale(3);
            }

            50% {
                opacity: 1;
                transform: scale(0.8);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fade-up {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes stars {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-50%);
            }
        }

        .debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            z-index: 9999;
            font-size: 0.8rem;
            width: 320px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .debug-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        .debug-tab {
            background: #333;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            font-size: 0.75rem;
            border: 1px solid #444;
        }

        .debug-tab.active {
            background: #e91e63;
            color: white;
            font-weight: bold;
            border-color: #e91e63;
        }

        .debug-btn {
            background: #555;
            color: white;
            border: 1px solid #777;
            padding: 4px 8px;
            margin: 2px;
            cursor: pointer;
            width: 100%;
            text-align: left;
        }

        .debug-btn:hover {
            background: #777;
        }
    </style>
</head>

<body>

    <div id="app" class="app-container" v-cloak>

        <div style="text-align: center;">
            <div class="logo">性癖俳句ロワイヤル</div>
        </div>

        <!-- 1. ロビー画面 -->
        <div v-if="viewState === 'LOBBY'" class="card-box" style="text-align:center;">
            <h2>入室</h2>
            <span v-if="errorMessage" class="error-msg">{{ errorMessage }}</span>

            <label>お名前</label>
            <input type="text" v-model="myPlayerName" placeholder="例：松尾芭蕉"
                style="width:100%; padding:10px; margin-bottom:15px; box-sizing:border-box;">

            <label>部屋番号（4桁）</label>
            <input type="text" v-model="roomId" maxlength="4" placeholder="1234"
                style="width:100%; padding:10px; margin-bottom:15px; box-sizing:border-box;">

            <button class="btn btn-primary" @click="enterRoom" :disabled="!roomId || !myPlayerName || isLoading">
                {{ isLoading ? '通信中...' : '部屋に入る / 作る' }}
            </button>
            <div style="margin-top:15px; text-align:center;">
                <label style="display:inline-flex; align-items:center; cursor:pointer; color:#555; font-size:0.85rem;">
                    <input type="checkbox" v-model="isTestMode" style="margin-right:6px;">
                    🛠️ テストモード (NPC機能など)
                </label>
            </div>

            <!-- ルームリセットボタン -->
            <div style="margin-top:20px; padding-top:15px; border-top:1px dashed #ccc;">
                <p style="font-size:0.8rem; color:#666; margin-bottom:8px;">前回のルーム情報をリセットしたい場合</p>
                <button class="btn" style="background:#888; font-size:0.85rem;" @click="resetRoom"
                    :disabled="!roomId || isLoading">
                    🗑️ ルーム情報をリセット
                </button>
            </div>

            <div style="margin-top:15px;">
                <button class="btn" style="background:var(--oni-color); font-size:1rem;" @click="openHallOfFame">
                    🏆 殿堂入りを見る
                </button>
            </div>
        </div>

        <!-- 2. ロビー（待機・設定）画面 -->
        <div v-else-if="viewState === 'WAITING'" class="card-box">
            <h2>ロビー / 設定</h2>
            <div style="text-align:center; margin-bottom:15px;">
                <p>現在 <strong>{{ players.length }}</strong> 名が待機中</p>
                <div
                    style="max-height: 150px; overflow-y: auto; text-align: left; background: #fff; border: 1px solid #ddd; padding: 10px; border-radius: 4px;">
                    <div v-for="p in players" :key="p.uid"
                        style="padding: 4px 0; border-bottom: 1px dotted #eee; display:flex; justify-content:space-between;">
                        <span>
                            <span v-if="p.uid === masterUid">👑</span>
                            <span v-else>👤</span>
                            {{ p.name }}
                            <span v-if="p.winCount && p.winCount > 0" class="win-badge"
                                style="font-size:0.8rem; margin-left:4px;">
                                <img src="./haiku_badge.png" class="win-icon" style="width:16px; height:16px;" alt="🏆">
                                {{ p.winCount }}
                            </span>
                        </span>
                        <span v-if="p.uid === myUid" style="font-size:0.8rem; color:#888;">(あなた)</span>
                    </div>
                </div>
            </div>

            <!-- 設定エリア (親のみ編集可) -->
            <div style="background:#f9f9f9; padding:15px; border-radius:8px; margin-bottom:20px;">
                <h3 style="margin-top:0;">ルール設定</h3>

                <div style="margin-bottom:10px;">
                    <label style="display:block; font-weight:bold;">⏳ 制限時間 (分)</label>
                    <div v-if="isMeMaster">
                        <input type="range" v-model.number="tempSettings.timeLimitMin" min="1" max="10" step="1"
                            style="width:100%;" @change="saveSettings">
                        <div style="text-align:right;">{{ tempSettings.timeLimitMin }} 分</div>
                    </div>
                    <div v-else>
                        {{ settings.timeLimit / 60 }} 分
                    </div>
                </div>

                <div style="margin-bottom:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label style="font-weight:bold;">🎭 親を表示する</label>
                        <div v-if="isMeMaster">
                            <input type="checkbox" v-model="tempSettings.showMaster" style="transform:scale(1.5);"
                                @change="saveSettings">
                        </div>
                        <div v-else>
                            {{ settings.showMaster ? 'ON' : 'OFF' }}
                        </div>
                    </div>
                    <p style="font-size:0.8rem; color:#666; margin-top:2px;">
                        {{ tempSettings.showMaster ? '誰が親か表示されます' : '誰が親かわかりません（ドキドキ！）' }}
                    </p>
                </div>

                <div style="margin-bottom:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label style="font-weight:bold;">📊 点数・順位を表示</label>
                        <div v-if="isMeMaster">
                            <input type="checkbox" v-model="tempSettings.showScore" style="transform:scale(1.5);"
                                @change="saveSettings">
                        </div>
                        <div v-else>
                            {{ settings.showScore ? 'ON' : 'OFF' }}
                        </div>
                    </div>
                    <p style="font-size:0.8rem; color:#666; margin-top:2px;">
                        OFFにすると勝ち負けを気にせず楽しめます
                    </p>
                </div>

                <div style="margin-bottom:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label style="font-weight:bold;">🎉 全員参加モード</label>
                        <div v-if="isMeMaster">
                            <input type="checkbox" v-model="tempSettings.everyonePlays" style="transform:scale(1.5);"
                                @change="saveSettings">
                        </div>
                        <div v-else>
                            {{ settings.everyonePlays ? 'ON' : 'OFF' }}
                        </div>
                    </div>
                    <p style="font-size:0.8rem; color:#666; margin-top:2px;">
                        親も俳句を詠み、いいねだけで競います（順位なし）
                    </p>
                </div>

                <div style="margin-bottom:10px;">
                    <label style="display:block; font-weight:bold;">🃏 配布枚数 (5文字)</label>
                    <div v-if="isMeMaster">
                        <input type="range" v-model.number="tempSettings.handSizeFive" min="1" max="10" step="1"
                            style="width:100%;" @change="saveSettings">
                        <div style="text-align:right;">{{ tempSettings.handSizeFive || 10 }} 枚</div>
                    </div>
                    <div v-else>
                        {{ settings.handSizeFive || 10 }} 枚
                    </div>
                </div>

                <div style="margin-bottom:10px;">
                    <label style="display:block; font-weight:bold;">🃏 配布枚数 (7文字)</label>
                    <div v-if="isMeMaster">
                        <input type="range" v-model.number="tempSettings.handSizeSeven" min="1" max="10" step="1"
                            style="width:100%;" @change="saveSettings">
                        <div style="text-align:right;">{{ tempSettings.handSizeSeven || 5 }} 枚</div>
                    </div>
                    <div v-else>
                        {{ settings.handSizeSeven || 5 }} 枚
                    </div>
                </div>

                <div style="margin-bottom:10px;">
                    <label style="display:block; font-weight:bold;">❤️ いいねの点数</label>
                    <div v-if="isMeMaster">
                        <input type="number" v-model.number="tempSettings.likePoints" min="0" max="100"
                            style="padding:5px; width:80px;" @change="saveSettings"> 点
                    </div>
                    <div v-else>
                        {{ settings.likePoints }} 点
                    </div>
                </div>

                <!-- ジャンル配分設定 -->
                <div style="margin-bottom:10px; padding:10px; background:#f5f5f5; border-radius:4px;">
                    <label style="display:block; font-weight:bold; margin-bottom:8px;">🎭 ジャンル配分</label>
                    <p style="font-size:0.75rem; color:#666; margin-bottom:8px;">
                        数値の比率でワードが選出されます（例: 3:6:1 → ノーマル30%）
                    </p>
                    <div v-if="isMeMaster" style="display:flex; gap:10px; flex-wrap:wrap; justify-content:center;">
                        <div style="text-align:center;">
                            <label style="font-size:0.8rem; color:#2e8b57;">ノーマル</label><br>
                            <input type="number" v-model.number="tempSettings.genreNormal" min="0" max="10"
                                style="width:50px; padding:5px; text-align:center;" @change="saveSettings">
                        </div>
                        <div style="text-align:center;">
                            <label style="font-size:0.8rem; color:#b93a32;">アブノーマル</label><br>
                            <input type="number" v-model.number="tempSettings.genreAbnormal" min="0" max="10"
                                style="width:50px; padding:5px; text-align:center;" @change="saveSettings">
                        </div>
                        <div style="text-align:center;">
                            <label style="font-size:0.8rem; color:#800080;">ネタ</label><br>
                            <input type="number" v-model.number="tempSettings.genreNeta" min="0" max="10"
                                style="width:50px; padding:5px; text-align:center;" @change="saveSettings">
                        </div>
                    </div>
                    <div v-else style="font-size:0.9rem; text-align:center;">
                        ノーマル:{{ settings.genreNormal || 0 }} / アブノーマル:{{ settings.genreAbnormal || 10 }} / ネタ:{{
                        settings.genreNeta || 0 }}
                    </div>
                </div>

                <!-- 俳句演出読み上げ設定 -->
                <div style="margin-bottom:10px;">
                    <label style="display:block; font-weight:bold;">🔊 俳句演出時の音声読み上げ</label>
                    <div v-if="isMeMaster" style="margin-top:5px;">
                        <label style="display:inline-flex; align-items:center; gap:5px; cursor:pointer;">
                            <input type="checkbox" v-model="tempSettings.speechEnabled" @change="saveSettings">
                            <span>読み上げを有効にする</span>
                        </label>
                        <p style="font-size:0.75rem; color:#666; margin-top:3px;">
                            ※ 俳句演出ON時に5・7・5のリズムで読み上げます
                        </p>
                    </div>
                    <div v-else style="font-size:0.9rem;">
                        {{ settings.speechEnabled ? '🔊 読み上げON' : '🔇 読み上げOFF' }}
                    </div>
                </div>
            </div>

            <div v-if="isMeMaster" style="text-align:center;">
                <button class="btn btn-primary" @click="startGame">ゲーム開始！</button>
            </div>
            <div v-else style="text-align:center; color:#666;">
                親が設定中です。開始をお待ちください...
            </div>

            <div style="margin-top:20px; text-align:center;">
                <button class="btn btn-danger" style="width:auto; padding:5px 10px; font-size:0.8rem;"
                    @click="leaveRoom">退出</button>
            </div>
        </div>

        <!-- 2. ゲーム画面 -->
        <div v-else-if="viewState === 'GAME'">

            <!-- ヘッダー情報 -->
            <div
                style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px; font-size:0.9rem; font-weight:bold;">
                <span>第 {{ roundCount }} / {{ players.length }} 句</span>
                <span>
                    親：{{ settings.showMaster ? getMasterName() : '???' }}
                </span>
                <button class="btn btn-danger" style="width:auto; padding:5px 10px; font-size:0.75rem;"
                    @click="leaveRoom">退出</button>
            </div>

            <!-- 順位表 -->
            <div class="card-box scoreboard">
                <div style="font-weight:bold; margin-bottom:5px; text-align:center;">現在の順位表</div>
                <div v-for="(p, index) in sortedPlayers" :key="p.uid" class="score-row">
                    <div style="display:flex; align-items:center;">
                        <span style="display:inline-block; width:20px; text-align:center; font-weight:bold;">
                            {{ settings.showScore ? (index + 1) : '-' }}
                        </span>
                        <span>{{ p.name }}</span>
                        <span v-if="p.winCount && p.winCount > 0" class="win-badge"
                            style="font-size:0.8rem; margin-left:4px;">
                            <img src="./haiku_badge.png" class="win-icon" style="width:16px; height:16px;" alt="🏆">
                            {{
                            p.winCount }}
                        </span>
                        <!-- 親表示設定がOFFのときは「親済」バッジも隠す（誰が親かわからないように） -->
                        <span v-if="settings.showMaster" class="master-badge"
                            :class="hasBeenMaster(p.uid) ? 'master-done' : 'master-yet'">
                            {{ hasBeenMaster(p.uid) ? '親済' : '親未' }}
                        </span>
                    </div>
                    <div>
                        <span class="heart-count">❤️ {{ p.totalLikes || 0 }}</span>
                        <b v-if="settings.showScore">{{ p.score }} pt</b>
                    </div>
                </div>
            </div>

            <!-- A. 詠唱タイム -->
            <div v-if="gamePhase === 'WRITING'">
                <div style="text-align:center; margin-bottom:10px;">
                    <p v-if="isMeMaster && !settings.everyonePlays">あなたは「親」です。皆の提出を待ちましょう。</p>
                    <p v-else>手札から最強の句を詠んでください。</p>
                    <!-- 全員に提出状況を表示 -->
                    <div style="background:#f0f0f0; padding:8px; border-radius:4px; margin-top:5px;">
                        📝 提出状況: <strong>{{ submittedCount }} / {{ settings.everyonePlays ? players.length :
                            players.length - 1 }}</strong> 人
                    </div>
                </div>

                <!-- 親の画面 (通常モード) -->
                <div v-if="isMeMaster && !settings.everyonePlays" class="card-box" style="text-align:center;">
                    <!-- 親用タイマー表示 -->
                    <div v-if="gamePhase === 'WRITING'"
                        style="margin-bottom:10px; padding:8px; background:#fff3e0; border-radius:4px; border:1px solid #ffcc80;">
                        <span v-if="timeLeft > 0"
                            style="font-size:1.1rem; font-weight:bold; color:var(--accent-color);">
                            ⏳ 残り {{ Math.floor(timeLeft / 60) }}:{{ ('0' + (timeLeft % 60)).slice(-2) }}
                        </span>
                        <span v-else style="font-size:1.1rem; font-weight:bold; color:red;">
                            ⏰ 時間終了！
                        </span>
                    </div>
                    <button class="btn btn-primary" @click="forceAllSubmit"
                        :disabled="submittedCount >= players.length - 1">
                        未提出者を強制提出させて次へ
                    </button>
                    <p style="font-size:0.8rem; color:#666; margin-top:5px;">※全員出すと自動で進みます</p>
                </div>

                <!-- 子の画面（または全員参加モードの全員） -->
                <div v-else>
                    <!-- 親用の強制進行ボタン（全員参加モード時） -->
                    <div v-if="isMeMaster && settings.everyonePlays" class="card-box"
                        style="text-align:center; margin-bottom:15px; background:#fff3e0;">
                        <p style="font-size:0.9rem; font-weight:bold; color:#e65100; margin-bottom:5px;">
                            あなたは親ですが、今回は参加者です！</p>
                        <button class="btn btn-secondary" @click="forceAllSubmit"
                            style="font-size:0.8rem; padding:4px 8px;" :disabled="submittedCount >= players.length">
                            強制的に次へ進む
                        </button>
                    </div>
                    <!-- プレビュー & リセット -->
                    <div class="haiku-preview">
                        <!-- 上五 -->
                        <div class="haiku-slot" :class="getSlotClass(myDraft.top)" @click="removePart('top')">
                            {{ myDraft.top ? myDraft.top.text : '（上五）' }}
                        </div>
                        <!-- 中七 -->
                        <div class="haiku-slot" :class="getSlotClass(myDraft.middle)" @click="removePart('middle')">
                            {{ myDraft.middle ? myDraft.middle.text : '（中七）' }}
                        </div>
                        <!-- 下五 -->
                        <div class="haiku-slot" :class="getSlotClass(myDraft.bottom)" @click="removePart('bottom')">
                            {{ myDraft.bottom ? myDraft.bottom.text : '（下五）' }}
                        </div>

                        <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                            <button class="btn btn-danger" @click="resetDraft" :disabled="hasSubmitted">
                                ↺ リセット (自由記入も削除)
                            </button>
                            <div style="font-size:0.9rem;">カード点: <b>{{ currentDraftScore }}</b></div>
                        </div>
                    </div>

                    <div v-if="!hasSubmitted">
                        <!-- 自由記入欄 (1回制限) -->
                        <div class="free-input-area">
                            <div style="font-size:0.8rem; font-weight:bold; margin-bottom:5px;">
                                🖊️ 自由記入 (1枚だけ作れます)
                            </div>
                            <div v-if="!hasCreatedFreeCard">
                                <div class="radio-group">
                                    <label><input type="radio" v-model="freeInputType" :value="5"> 5文字(上/下)</label>
                                    <label><input type="radio" v-model="freeInputType" :value="7"> 7文字(中)</label>
                                </div>
                                <div class="input-row">
                                    <input type="text" v-model="freeInputText" placeholder="好きな言葉"
                                        style="flex-grow:1; padding:5px;">
                                    <button class="btn btn-add" @click="addFreeCard"
                                        :disabled="!freeInputText">追加</button>
                                </div>
                            </div>
                            <div v-else style="font-size:0.85rem; color:#2e8b57; text-align:center;">
                                ※ 自由記入カード作成済み
                            </div>
                        </div>

                        <!-- 手札リスト -->
                        <div class="hand-section">
                            <div class="hand-label">【五文字】タップで上・下にセット</div>
                            <div class="card-list">
                                <div v-for="card in myHand.fives" :key="card.id" class="word-card"
                                    :class="getCardClass(card)" @click="selectFive(card)">
                                    {{ card.text }}
                                    <span class="point-badge">{{ card.score }}</span>
                                </div>
                            </div>
                        </div>

                        <div class="hand-section" style="margin-top:15px;">
                            <div class="hand-label">【七文字】タップで中にセット</div>
                            <div class="card-list">
                                <div v-for="card in myHand.sevens" :key="card.id" class="word-card"
                                    :class="getCardClass(card)" @click="selectSeven(card)">
                                    {{ card.text }}
                                    <span class="point-badge">{{ card.score }}</span>
                                </div>
                            </div>
                        </div>

                        <div style="margin-top:15px; text-align:center;">
                            <label
                                style="display:inline-flex; align-items:center; gap:5px; padding:8px; background:#fff8dc; border:1px solid #ffd700; border-radius:4px; font-weight:bold; cursor:pointer;">
                                <input type="checkbox" v-model="useSpecialEffect" :disabled="hasMySpecialEffectUsed">
                                <span>✨ 俳句演出 (1試合に1回のみ)</span>
                            </label>
                            <div v-if="hasMySpecialEffectUsed" style="font-size:0.75rem; color:red; margin-top:2px;">
                                ※ すでに演出を使用済みです
                            </div>
                        </div>

                        <!-- タイマー表示 -->
                        <div v-if="gamePhase === 'WRITING'"
                            style="text-align:center; margin-bottom:10px; padding:8px; background:#fff3e0; border-radius:4px; border:1px solid #ffcc80;">
                            <span v-if="timeLeft > 0"
                                style="font-size:1.1rem; font-weight:bold; color:var(--accent-color);">
                                ⏳ 残り {{ Math.floor(timeLeft / 60) }}:{{ ('0' + (timeLeft % 60)).slice(-2) }}
                            </span>
                            <span v-else style="font-size:1.1rem; font-weight:bold; color:red;">
                                ⏰ 時間終了！
                            </span>
                        </div>

                        <button class="btn btn-primary" style="margin-top:10px;" @click="submitHaiku"
                            :disabled="!myDraft.top || !myDraft.middle || !myDraft.bottom">
                            詠む（提出）
                        </button>
                    </div>
                    <div v-else class="card-box" style="text-align:center;">
                        <p>提出完了！<br>親の選評を待っています...</p>
                    </div>
                </div>
            </div>

            <!-- B. 選評タイム -->
            <div v-if="gamePhase === 'JUDGING'">
                <div class="card-box" style="text-align:center;">
                    <h3>選評タイム</h3>
                    <p v-if="isMeMaster && !settings.everyonePlays">グッときた順に順位をつけてください</p>
                    <p v-else-if="settings.everyonePlays">全員で好きな句にいいねしましょう！</p>
                    <p v-else>親が選考中です…</p>

                    <!-- 全体のいいね状況 -->
                    <div
                        style="background:#fff0f5; padding:5px; border-radius:4px; margin-top:5px; border:1px solid #ffb6c1; font-size:0.9rem;">
                        ❤️ 全員のいいね状況: <strong>{{ likedCount }} / {{ likeTargetCount }}</strong> 人
                    </div>

                    <!-- いいね進捗表示（親以外の参加者向け） -->
                    <div v-if="!isMeMaster || settings.everyonePlays"
                        style="margin-top:10px; padding:10px; background:#fff0f5; border-radius:8px; border:1px solid #ffb6c1;">
                        <div v-if="hasLikedAny" style="color:#28a745; font-weight:bold;">
                            ✅ いいね済み！（1句選択完了）
                        </div>
                        <div v-else style="color:#dc3545; font-weight:bold;">
                            ⚠️ いいね必須！1句だけ❤️を押してください
                        </div>
                    </div>
                </div>

                <div v-for="haiku in sortedHaikusForJudging" :key="haiku.id" class="tanzaku">
                    <div style="font-size:1.2rem; font-weight:bold; text-align:center; margin-bottom:5px;">
                        <span :style="{color: haiku.top.isOni ? 'purple' : 'inherit'}">{{ haiku.top.text }}</span>　
                        <span :style="{color: haiku.middle.isOni ? 'purple' : 'inherit'}">{{ haiku.middle.text
                            }}</span>　
                        <span :style="{color: haiku.bottom.isOni ? 'purple' : 'inherit'}">{{ haiku.bottom.text
                            }}</span>
                    </div>

                    <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#888;">
                        <span>カード点: {{ haiku.cardScore }}</span>
                        <span>詠み人知らず</span>
                    </div>

                    <div v-if="isMeMaster && !settings.everyonePlays"
                        style="margin-top:10px; border-top:1px dashed #ccc; padding-top:10px; text-align:center;">
                        <button v-for="r in [1,2,3]" :key="r" @click="setRank(haiku, r)"
                            :style="{background: (tempRankState[haiku.id] === r) ? 'var(--accent-color)' : '#ccc', color:'white', border:'none', padding:'5px 10px', margin:'0 3px', borderRadius:'4px'}">
                            {{ r }}位
                        </button>
                    </div>
                    <!-- いいね・お気に入りボタン（自分の俳句以外に表示、親もお気に入り可能） -->
                    <div v-if="haiku.userId !== myUid"
                        style="text-align:right; margin-top:5px; display:flex; justify-content:flex-end; gap:5px; flex-wrap:wrap;">
                        <!-- いいねボタン（親以外のみ） -->
                        <button v-if="!isMeMaster || settings.everyonePlays" @click="toggleLike(haiku)"
                            :disabled="hasLikedAny && !(haiku.likes && haiku.likes.includes(myUid))" :style="{
                                background: (haiku.likes && haiku.likes.includes(myUid)) ? '#e91e63' : 'none',
                                color: (haiku.likes && haiku.likes.includes(myUid)) ? 'white' : '#333',
                                border: '1px solid #ccc',
                                borderRadius: '15px',
                                padding: '5px 15px',
                                cursor: (hasLikedAny && !(haiku.likes && haiku.likes.includes(myUid))) ? 'not-allowed' : 'pointer',
                                opacity: (hasLikedAny && !(haiku.likes && haiku.likes.includes(myUid))) ? '0.5' : '1'
                            }">
                            {{ (haiku.likes && haiku.likes.includes(myUid)) ? '❤️ いいね済' : '🤍 いいね' }}
                        </button>
                        <!-- お気に入りボタン (全員利用可能) -->
                        <button @click="toggleFavorite(haiku)" :style="{
                            background: (getMyFavoriteHaikuId() === haiku.id) ? 'var(--fav-color)' : 'none',
                            color: (getMyFavoriteHaikuId() === haiku.id) ? 'white' : '#333',
                            border: '1px solid #ccc',
                            borderRadius: '15px',
                            padding: '5px 15px',
                            cursor: 'pointer'
                        }">
                            {{ (getMyFavoriteHaikuId() === haiku.id) ? '★ お気に入り済' : '☆ お気に入り' }}
                        </button>
                    </div>
                </div>

                <!-- 親の強制進行ボタン -->
                <div v-if="isMeMaster" style="margin-top:20px;">
                    <button class="btn btn-primary" @click="finalizeJudging" :disabled="!canFinalize">
                        {{ settings.everyonePlays ? '集計して結果発表へ' : '順位決定・発表' }}
                    </button>
                    <button class="btn btn-danger" style="margin-top:10px;"
                        @click="forceFinalize">強制進行（いいね未完了でも進む）</button>
                </div>
            </div>

            <!-- C. 結果発表 -->
            <div v-if="gamePhase === 'RESULT'">
                <div class="card-box" style="text-align:center; background:var(--sub-color); color:#fff;">
                    <h3>結果発表</h3>
                </div>

                <div v-for="(haiku, index) in sortedHaikusForDisplay" :key="haiku.id" class="tanzaku"
                    v-show="visibleResultCount >= (sortedHaikusForDisplay.length - index)">

                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <div>
                            <span v-if="!settings.showScore" class="rank-badge"
                                style="background:#eee; color:#666;">発表</span>
                            <span v-else-if="(haiku.rank || haiku._virtualRank)===1" class="rank-badge"
                                style="background:var(--gold-color);">1位
                                {{ settings.everyonePlays ? '' : '(100pt)' }}</span>
                            <span v-else-if="(haiku.rank || haiku._virtualRank)===2" class="rank-badge"
                                style="background:silver;">2位
                                {{ settings.everyonePlays ? '' : '(60pt)' }}</span>
                            <span v-else-if="(haiku.rank || haiku._virtualRank)===3" class="rank-badge"
                                style="background:#ad8a80;">3位
                                {{ settings.everyonePlays ? '' : '(20pt)' }}</span>
                            <span v-else class="rank-badge" style="background:#eee; color:#666;">
                                {{ (haiku.rank || haiku._virtualRank) ? (haiku.rank || haiku._virtualRank) + '位' :
                                '圏外'
                                }}
                            </span>
                        </div>
                        <div style="font-size:0.8rem;">
                            <!-- 点数表示ONの場合: 詳細計算式 -->
                            <span v-if="settings.showScore">
                                カード:{{ haiku.cardScore }} + <span v-if="!settings.everyonePlays">順位:{{
                                    getRankScore(haiku.rank) }} + </span>
                                <span style="color:#e91e63;">❤️:{{ (haiku.likes ? haiku.likes.length : 0) *
                                    settings.likePoints }}</span> =
                                <b>{{ haiku.totalScore }}pt</b>
                            </span>
                            <!-- 点数表示OFFの場合: シンプル表示 -->
                            <span v-else>
                                <span style="color:#e91e63; font-weight:bold; font-size:1rem;">❤️ {{ (haiku.likes ?
                                    haiku.likes.length : 0) }}</span>
                            </span>
                        </div>
                    </div>

                    <div style="font-size:1.2rem; font-weight:bold; text-align:center; margin:10px 0;">
                        {{ haiku.top.text }}　{{ haiku.middle.text }}　{{ haiku.bottom.text }}
                    </div>
                    <div style="text-align:right; font-weight:bold; color:var(--sub-color);">
                        詠：{{ getPlayerName(haiku.userId) }}
                    </div>
                </div>

                <div v-if="isMeMaster && isResultAnimationDone" style="margin-top:20px;">
                    <button class="btn btn-primary" @click="nextRound">次の句へ</button>
                </div>
                <div v-if="!isMeMaster && isResultAnimationDone" style="margin-top:20px; text-align:center;">
                    <p>次の展開を待っています...</p>
                </div>
            </div>
        </div>

        <!-- 3. 最終結果 -->
        <div v-else-if="viewState === 'FINISHED'" class="card-box" style="text-align:center;">
            <h2>最終結果</h2>
            <div v-for="(p, i) in sortedPlayers" :key="p.uid" class="score-row">
                <span>
                    <span v-if="settings.showScore">{{ i+1 }}位 </span>
                    {{ p.name }}
                    <span class="heart-count">❤️ {{ p.totalLikes || 0 }}</span>
                    <!-- 優勝バッジ＆回数表示 -->
                    <span v-if="p.winCount && p.winCount > 0" class="win-badge">
                        <img src="./haiku_badge.png" class="win-icon" alt="🏆"> {{ p.winCount }}回優勝
                    </span>
                </span>
                <strong v-if="settings.showScore">{{ p.score }} pt</strong>
            </div>

            <!-- MVP俳句表示エリア -->
            <div v-if="topLikedHaikus.length > 0" style="margin-top:30px; text-align:center;">
                <h3 style="color:#e91e63; border-bottom:2px dashed #e91e63; display:inline-block; padding-bottom:5px;">
                    🏆 今日のMVP俳句 🏆
                </h3>
                <div v-for="(h, idx) in topLikedHaikus" :key="h.id" class="tanzaku"
                    style="margin-bottom:15px; border:2px solid gold; box-shadow:0 0 10px rgba(255, 215, 0, 0.4);">

                    <div style="font-size:0.9rem; font-weight:bold; color:#e91e63; margin-bottom:5px;">
                        {{ idx + 1 }}位 (❤️ {{ h.likes ? h.likes.length : 0 }})
                    </div>

                    <div style="font-size:1.3rem; font-weight:bold; margin:10px 0;">
                        {{ h.top.text }}　{{ h.middle.text }}　{{ h.bottom.text }}
                    </div>

                    <div style="text-align:right; font-weight:bold; color:var(--sub-color); font-size:0.9rem;">
                        詠：{{ getPlayerName(h.userId) }}
                    </div>
                </div>
            </div>

            <!-- お気に入り俳句表示エリア -->
            <div v-if="getFavoritedHaikusSummary().length > 0" style="margin-top:30px; text-align:center;">
                <h3
                    style="color:var(--fav-color); border-bottom:2px dashed var(--fav-color); display:inline-block; padding-bottom:5px;">
                    ★ みんなのお気に入り俳句 ★
                </h3>
                <div v-for="(item, idx) in getFavoritedHaikusSummary()" :key="idx" class="tanzaku"
                    style="margin-bottom:15px; border:2px solid var(--fav-color); background:#fffaf0;">
                    <div style="font-size:0.9rem; font-weight:bold; color:var(--fav-color); margin-bottom:5px;">
                        選者: {{ item.fanNames.join('、') }}
                    </div>
                    <div style="font-size:1.3rem; font-weight:bold; margin:10px 0;">
                        {{ item.haiku.top.text }}　{{ item.haiku.middle.text }}　{{ item.haiku.bottom.text }}
                    </div>
                    <div style="text-align:right; font-weight:bold; color:var(--sub-color); font-size:0.9rem;">
                        詠：{{ getPlayerName(item.haiku.userId) }}
                    </div>
                </div>
            </div>
            <br>
            <br>
            <div v-if="isMeMaster">
                <button class="btn btn-primary" @click="startNextGame">次のゲームを設定する</button>
            </div>
            <div v-else>
                <p>親が次のゲームを開始するのを待っています...</p>
            </div>
            <div style="margin-top:15px;">
                <button class="btn btn-danger" @click="leaveRoom">部屋を抜ける</button>
            </div>


            <div style="margin-top:15px;" v-if="isMeMaster">
                <button class="btn" style="background:var(--oni-color);" @click="addToHallOfFame">
                    💾 殿堂入りに登録
                </button>
            </div>
            <div style="margin-top:15px;">
                <button class="btn" style="background:#888; font-size:0.85rem;" @click="resetRoom">
                    🗑️ ルーム情報を完全にリセット
                </button>
            </div>
        </div>

        <!-- 4. 殿堂入り閲覧画面 -->
        <div v-else-if="viewState === 'HALL_OF_FAME'" class="card-box" style="text-align:center;">
            <div style="background:var(--oni-color); color:#fff; padding:10px; margin-bottom:15px; border-radius:4px;">
                <h2>🏆 殿堂入り 🏆</h2>
            </div>

            <div style="margin-bottom:20px; display:flex; justify-content:center; gap:10px;">
                <button class="btn" @click="closeHallOfFame">戻る</button>
                <button class="btn" style="background:#888; font-size:0.8rem;" @click="resetHallOfFame"
                    v-if="hallOfFameList.length > 0">
                    🗑️ 全て削除
                </button>
            </div>

            <div v-if="hallOfFameList.length === 0">
                <p>まだ殿堂入りの記録はありません。</p>
            </div>

            <div v-for="record in hallOfFameList" :key="record.id" class="card-box"
                style="margin-bottom:20px; border:1px solid #ddd; text-align:left;">

                <div
                    style="background:#f0f0f0; padding:5px 10px; border-bottom:1px solid #ccc; font-size:0.9rem; display:flex; justify-content:space-between;">
                    <strong>{{ formatDate(record.createdAt) }}</strong>
                    <span>ルーム: {{ record.roomId }}</span>
                </div>

                <!-- 概要（クリックで展開） -->
                <div style="padding:10px; cursor:pointer;" @click="toggleHallOfFameDetail(record.id)">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <span>
                            <strong>👑 優勝:</strong>
                            <span v-if="record.players && record.players.length > 0">
                                {{ record.players[0].name }} ({{ record.players[0].score }}pt)
                            </span>
                        </span>
                        <span style="font-size:0.8rem; color:#666;">
                            {{ expandedRecordId === record.id ? '▲ 閉じる' : '▼ 詳細を見る' }}
                        </span>
                    </div>
                </div>

                <!-- 詳細（展開時のみ表示） -->
                <div v-if="expandedRecordId === record.id"
                    style="padding:10px; border-top:1px dashed #ddd; background:#fafafa;">
                    <!-- 参加者リスト -->
                    <div style="margin-bottom:15px;">
                        <div style="font-weight:bold; margin-bottom:5px;">👥 参加者と成績</div>
                        <div v-for="p in record.players" :key="p.uid"
                            style="font-size:0.9rem; border-bottom:1px dotted #ccc; padding:2px 0;">
                            <span>{{ p.name }} ({{ p.score }}pt)</span>
                            <span v-if="p.favoriteHaikuId"
                                style="display:block; font-size:0.8rem; color:var(--fav-color); margin-left:10px;">
                                ↳ ★ {{ getHaikuTextFromRecord(record, p.favoriteHaikuId) }}
                            </span>
                        </div>
                    </div>

                    <!-- MVP俳句 -->
                    <div v-if="record.mvpHaikus && record.mvpHaikus.length > 0" style="margin-bottom:15px;">
                        <div style="font-weight:bold; color:#e91e63; margin-bottom:5px;">[MVP俳句]</div>
                        <div v-for="(h, i) in record.mvpHaikus" :key="i" class="tanzaku"
                            style="margin-bottom:5px; padding:5px; border:1px solid gold; font-size:1rem;">
                            {{ i+1 }}位: {{ h.top.text }} {{ h.middle.text }} {{ h.bottom.text }}
                            <br><span style="font-size:0.8rem; color:#666;">(詠: {{ getPlayerNameFromRecord(record,
                                h.userId) }})</span>
                        </div>
                    </div>

                    <!-- お気に入り俳句 -->
                    <div v-if="getFavoritedHaikusFromRecord(record).length > 0">
                        <div style="font-weight:bold; color:var(--fav-color); margin-bottom:5px;">[お気に入り俳句]</div>
                        <div v-for="(item, idx) in getFavoritedHaikusFromRecord(record)" :key="idx" class="tanzaku"
                            style="margin-bottom:5px; padding:5px; border:1px solid var(--fav-color); font-size:1rem; background:#fffaf0;">
                            ★ {{ item.haiku.top.text }} {{ item.haiku.middle.text }} {{ item.haiku.bottom.text }}
                            <br><span style="font-size:0.8rem; color:#666;">(詠: {{ getPlayerNameFromRecord(record,
                                item.haiku.userId) }}) / 選: {{ item.fanNames.join('、') }}</span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 5. 俳句演出オーバーレイ -->
        <transition name="fade">
            <div v-if="showSpecialEffectOverlay && specialEffectHaiku" class="special-overlay">
                <div class="special-content">
                    <div class="special-bg"></div>
                    <div class="special-text">
                        <transition name="fade">
                            <div v-if="visiblePhraseIndex >= 0" class="phrase top">{{ specialEffectHaiku.top.text }}
                            </div>
                        </transition>
                        <transition name="fade">
                            <div v-if="visiblePhraseIndex >= 1" class="phrase middle">{{ specialEffectHaiku.middle.text
                                }}</div>
                        </transition>
                        <transition name="fade">
                            <div v-if="visiblePhraseIndex >= 2" class="phrase bottom">{{ specialEffectHaiku.bottom.text
                                }}</div>
                        </transition>
                    </div>
                    <div class="special-footer" v-if="visiblePhraseIndex >= 2">
                        渾身の一句！！
                    </div>
                </div>
            </div>
        </transition>

        <!-- デバッグメニュー -->
        <!-- デバッグメニュー -->
        <div class="debug-panel" v-if="viewState !== 'LOBBY' && isTestMode">
            <div style="font-weight:bold; margin-bottom:5px;">🛠️ テスト/デバッグ</div>

            <!-- プレイヤー切り替えタブ -->
            <div class="debug-tabs">
                <div v-for="p in players" :key="p.uid" class="debug-tab" :class="{ active: p.uid === myUid }"
                    @click="switchPlayer(p.uid)">
                    {{ p.name }}
                </div>
            </div>

            <div v-if="viewState === 'WAITING'">
                <button class="debug-btn" @click="add3NPCs">🤖 NPCを3人追加</button>
            </div>

            <div style="margin-top:5px; border-top:1px solid #555; padding-top:5px;">
                <div style="font-size:0.7rem;">現在の視点: <span style="font-weight:bold; color:#e91e63;">{{
                        getPlayerName(myUid)
                        }}</span></div>
                <button class="debug-btn" @click="npcSubmitAll" v-if="gamePhase === 'WRITING'">📝 他全員提出(強制)</button>
                <button class="debug-btn" @click="npcLikeAll" v-if="gamePhase === 'JUDGING'">❤️ 他全員いいね(強制)</button>
                <button class="debug-btn" @click="npcMasterJudge"
                    v-if="gamePhase === 'JUDGING' && masterUid && masterUid.startsWith('npc-')">👑
                    NPC親投票＆完了(強制)</button>
            </div>
        </div>
    </div>

    <!-- Vue & Firebase Logic -->
    <script type="module">
        import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import {
            getFirestore, collection, doc, getDoc, setDoc, updateDoc,
            onSnapshot, addDoc, arrayUnion, increment, writeBatch, deleteDoc, getDocs
        } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // ▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼▼
        // ここにあなたのFirebase Configを貼り付けてください！
        // ▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲▲
        const firebaseConfig = {
            apiKey: "AIzaSyCQk8FAwozz34jdqoW6wxFqeneaOtA_AP4",
            authDomain: "word-wolf-1432f.firebaseapp.com",
            databaseURL: "https://word-wolf-1432f-default-rtdb.firebaseio.com",
            projectId: "word-wolf-1432f",
            storageBucket: "word-wolf-1432f.firebasestorage.app",
            messagingSenderId: "777084245986",
            appId: "1:777084245986:web:a6976ec8ee22a110dbcbbb"
        };

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase Init Error:", e);
        }

        // --- 辞書データ ---
        // genre: "normal"(ノーマル), "abnormal"(アブノーマル), "neta"(ネタ)
        const WORD_DICTIONARY = [
            // ============================================
            // 【５文字 (上/下)】
            // ============================================

            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // ■ ノーマル (5文字)
            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            { text: "会社にて", type: 5, score: 3, isOni: false, genre: "normal" },
            { text: "エレベーター", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "三時間", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "雨の中", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "飲み会で", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "生配信", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "お嬢様", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "ビデオレター", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "美人秘書", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "旦那様", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "一時間", type: 5, score: 3, isOni: false, genre: "normal" },
            { text: "ベッドにて", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "二人きり", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "個室にて", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "先生と", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "こっそりと", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "教室で", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "帰り道", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "制服で", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "秘密だよ", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "見ないでよ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "目を閉じて", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "抱きしめて", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "耳元で", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "夏の夜", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "試着室", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "お母さん", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "お姉さん", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "合コンで", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "入れてみる", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "出してみて", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "激しくて", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "乱れてる", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "飲み込んで", type: 5, score: 6, isOni: false, genre: "normal" },
            { text: "我慢して", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "恥ずかしい", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "抱き寄せて", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "愛してる", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "味わって", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "暴れ出す", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "間違えて", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "首輪付け", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "課金した", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "推し活で", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "オフ会で", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "便秘気味", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "逆噴射", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "ぶっこ抜き", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "入らない", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "硬すぎる", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "太すぎる", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "早すぎる", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "濡れてるよ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "びっしょびしょ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "ヌルヌルだ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "パンパンだ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "キツキツだ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "擦れてる", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "敏感だ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "生がいい", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "皮むいて", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "舐めたいな", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "脱ぎなよ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "上手だね", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "吸い付いて", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "挟んでよ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "先っぽが", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "踏んでくれ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "勘違い", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "気のせいか", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "夢オチだ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "初対面", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "他人です", type: 5, score: 4, isOni: false, genre: "normal" },
            { text: "元カノと", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "浮気バレ", type: 5, score: 6, isOni: false, genre: "normal" },
            { text: "修羅場だよ", type: 5, score: 6, isOni: false, genre: "normal" },
            { text: "警察だ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "逮捕され", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "泣き叫ぶ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "呪われて", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "異世界へ", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "転生し", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "勇者様", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "お風呂場で", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "洗脳済", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "無表情", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "高笑い", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "年齢差", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "体格差", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "押し倒し", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "行きずりの", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "地味眼鏡", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "イケメンと", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "洗脳し", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "腹パンで", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "鏡張り", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "未開発", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "主従関係", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "掘りまくる", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "オプションで", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "コスプレで", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "催眠で", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "首絞めて", type: 5, score: 5, isOni: false, genre: "normal" },
            { text: "バイブ音", type: 5, score: 5, isOni: false, genre: "normal" },

            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // ■ アブノーマル (5文字)
            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // 通常カード
            { text: "ピンサロで", type: 5, score: 4, isOni: false, genre: "abnormal" },
            { text: "団地妻", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ムッチムチ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "四つん這い", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "肉便器", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "寝取られて", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "乳首責め", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "百合えっち", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ショタちんこ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "初体験", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "筆おろし", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "断面図", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "着衣えろ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "親子丼", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ぶっともも", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "フル勃起", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "モブおじさん", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "エロ睡眠", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "姫はじめ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "経産婦", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "発情期", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "バイアグラ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "パイズリで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "立ちバック", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "おパンティ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ど変態", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "今日しよう❤", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "中でいいよ❤", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "どびゅるるる", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "おまんこに", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ケツを出せ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "風俗嬢", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ソープにて", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "デリヘルで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "中イキで", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "潮吹きを", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "愛人と", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "パパ活で", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "生で出す", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ゴム無しで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "精飲を", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "イラマチオ", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "クリトリス", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "膣の中", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ガチイキで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "即尺で", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "指マンで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "浣腸し", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "Gスポット", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "触手責め", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "雌豚と", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "寝取らせて", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "交尾中", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "拘束具", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "言葉責め", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "誘い受け", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "スケベ椅子", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "隠し撮り", type: 5, score: 4, isOni: false, genre: "abnormal" },
            { text: "まんこくぱぁ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "露出狂", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "エネマグラ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "猿ぐつわ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "中出しで", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "外出しで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "顔射して", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "手コキして", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "足コキで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "パイズリで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "大陰茎", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "3Pで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "乱交だ", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "クリを責め", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "潮吹いた", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "失禁し", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "ザーメンを", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "マン汁を", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "我慢汁", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "名器だな", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "締まり良し", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ガバガバだ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "パイパンの", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "即ハメで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "生で入れ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "バックから", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "騎乗位で", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "顔騎して", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "駅弁で", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "四つん這い", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "尻を振れ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "尻穴が", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "お尻好き", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "尻叩き", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "スパンキング", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "締まるケツ", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "アナニーで", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "イかせてやる", type: 5, score: 6, isOni: false, genre: "abnormal" },
            { text: "抜いてあげる", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "踏んであげる", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "跪け", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "豚野郎", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "男同士", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "男の娘", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "女装して", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "メスになり", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "ケツ貸しな", type: 5, score: 5, isOni: false, genre: "abnormal" },
            { text: "孕ませて", type: 5, score: 6, isOni: false, genre: "abnormal" },
            // 鬼札
            { text: "バブみある", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "触手攻め", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "デスアクメ", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "ケツアクメ", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "ザコまんこ", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "尊厳破壊", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "鬱勃起", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "二穴責め", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "授乳コキ", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "逆レイプ", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "無様エロ", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "イマラチオ", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "ケツマンコ", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "アヘ顔で", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "オナホばれ", type: 5, score: 10, isOni: true, genre: "abnormal" },
            { text: "おじチンポ", type: 5, score: 10, isOni: true, genre: "abnormal" },

            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // ■ ネタ (5文字)
            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // 通常カード
            { text: "推しの子が", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "うわキッツ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "うわデッカ", type: 5, score: 6, isOni: false, genre: "neta" },
            { text: "Oh.YES", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "や・ら・な・い・か", type: 5, score: 8, isOni: false, genre: "neta" },
            { text: "VTuber", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "神回避", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "倍返し", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "草生える", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "待って無理", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "尊すぎ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "知らんけど", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "フラグ立つ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "残像だ", type: 5, score: 6, isOni: false, genre: "neta" },
            { text: "だが断る", type: 5, score: 6, isOni: false, genre: "neta" },
            { text: "若さゆえ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "逃げちゃだめ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "海賊王", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "うｐ乙です", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "パチパチと", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "うっせぇわ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "異世界へ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "大草原", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "逝ってよし", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "ホンマそれ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "ザ・ワールド", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "三連戦", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "ご立派ぁ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "ゲットだぜ", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "アンパンマン", type: 5, score: 5, isOni: false, genre: "neta" },
            { text: "By みつを", type: 5, score: 5, isOni: false, genre: "neta" },

            // 鬼札
            { text: "黒歴史", type: 5, score: 10, isOni: true, genre: "neta" },
            { text: "あんたバカぁ？", type: 5, score: 10, isOni: true, genre: "neta" },
            { text: "ユニコーン！！", type: 5, score: 10, isOni: true, genre: "neta" },
            { text: "やらせはせん", type: 5, score: 10, isOni: true, genre: "neta" },

            // ============================================
            // 【７文字 (中)】
            // ============================================

            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // ■ ノーマル (7文字)
            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            { text: "一生懸命", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "電気を消して", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "シャワーを浴びて", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "声を抑えて", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "我慢しないで", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "素直になって", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "優しく触れて", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "体が熱い", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "初めてだから", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "震える指で", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "準備はいいか", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "一線越える", type: 7, score: 6, isOni: false, genre: "normal" },
            { text: "秘密の契約", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "夜はこれから", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "妄想捗る", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "脱ぎ捨てていく", type: 7, score: 6, isOni: false, genre: "normal" },
            { text: "洗い流して", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "誘ってるよね", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "録画していた", type: 7, score: 6, isOni: false, genre: "normal" },
            { text: "壊れちゃった", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "溢れ出しそう", type: 7, score: 6, isOni: false, genre: "normal" },
            { text: "奥の方まで", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "優しくしてね", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "激しく動く", type: 7, score: 6, isOni: false, genre: "normal" },
            { text: "声を殺して", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "限界突破", type: 7, score: 6, isOni: false, genre: "normal" },
            { text: "期待外れね", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "よくできました", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "興奮してる", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "刺激が強い", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "初めて見たよ", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "大きすぎたの", type: 7, score: 6, isOni: false, genre: "normal" },
            { text: "トイレが詰まる", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "皮が剥けた", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "大きくして", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "下半身が", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "処理をする", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "穴があった", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "白い液体", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "テクニック", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "道具使って", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "ひとり遊び", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "時間が止まる", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "夜明け近づく", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "季節は巡って", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "何かが変わる", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "写真に残す", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "思い出にして", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "汗ばんだ肌", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "スカートまくり", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "壁に押し付け", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "耳元で言う", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "理性が飛んで", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "ぴっちりスーツ", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "睡眠アプリ", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "隣の部屋で", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "言いなりになる", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "ガマンできずに", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "気持ちよすぎて", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "公衆トイレ", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "腰を振ってよ", type: 7, score: 5, isOni: false, genre: "normal" },
            { text: "顔にまたがり", type: 7, score: 5, isOni: false, genre: "normal" },
            // 鬼札
            { text: "先っちょだけ", type: 7, score: 5, isOni: true, genre: "normal" },
            { text: "全てを無にする", type: 7, score: 5, isOni: true, genre: "normal" },
            { text: "枕営業", type: 7, score: 5, isOni: true, genre: "normal" },
            { text: "大人の関係", type: 7, score: 5, isOni: true, genre: "normal" },
            { text: "完全犯罪", type: 7, score: 5, isOni: true, genre: "normal" },

            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // ■ アブノーマル (7文字)
            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // 通常カード
            { text: "声が漏れちゃう", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "ギリギリ見えた", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "絶対服従", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "絶頂迎える", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "脚ピンオナニー", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "分からせえっち", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "寝取られ報告", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "子作りえっち", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "裸エプロン", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "射精懇願", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "陥没乳首", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "射精管理で", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "M字開脚", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "連続絶頂", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "絶叫痙攣", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "おしっこ我慢", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "感度千倍", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "おちんぽみるく", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "アナルセックス", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "シックスナイン", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "ニプルファック", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "フィストファック", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "口内射精", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "援助交際", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "複数プレイ", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "顔面騎乗", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "クンニリングス", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "まんぐり返し", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "オナホを使って", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "アヘ顔晒す", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "ビデオ回して", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "何度もイっちゃう", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "ナカで暴れる", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "腰が砕ける", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "女を抱いて", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "騎乗位キメて", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "いちゃらぶえっち", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "ピストン運動", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "チンコを舐める", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "ローションプレイ", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "ローター散歩", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "異物挿入", type: 7, score: 7, isOni: false, genre: "abnormal" },
            { text: "スパンキングで", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "双頭ディルド", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "即ハメえっち", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "ワンナイトラブ", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "数の子天井", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "仮性包茎", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "ドリルちんちん", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "尻コキえっち", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "足コキえっち", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "パイズリえっち", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "駅弁大好き❤", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "ディープスロート", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "一人尺八", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "中出しセックス", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "子作りセックス", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "ピンクローター", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "三角木馬", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "オホ声響く", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "亀甲縛り", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "チンカス香る", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "おしりを舐める", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "子宮恋愛", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "イク❤イク❤イっちゃう❤", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "くぎ打ち騎乗位", type: 7, score: 4, isOni: false, genre: "abnormal" },
            { text: "拘束電マ", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "高速ピストン", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "電マを当てて", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "バイブを入れて", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "アナルを掘って", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "ソープへ行こう", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "パイズリ最高", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "子宮に届く", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "黄金プレイ", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "強制絶頂", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "連続絶頂", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "アナル拡張", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "尿道責めて", type: 7, score: 7, isOni: false, genre: "abnormal" },
            { text: "メスイキ指導", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "野外プレイで", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "露出プレイで", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "膣内射精", type: 7, score: 6, isOni: false, genre: "abnormal" },
            { text: "対面座位で", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "背面座位で", type: 7, score: 5, isOni: false, genre: "abnormal" },
            { text: "がばがばアナル", type: 7, score: 6, isOni: false, genre: "abnormal" },
            // 鬼札
            { text: "大量失禁", type: 7, score: 10, isOni: true, genre: "abnormal" },
            { text: "ふたなり巨乳", type: 7, score: 15, isOni: true, genre: "abnormal" },
            { text: "チン媚ダンス", type: 7, score: 10, isOni: true, genre: "abnormal" },
            { text: "縦割れあなる", type: 7, score: 10, isOni: true, genre: "abnormal" },
            { text: "濁点喘ぎ", type: 7, score: 10, isOni: true, genre: "abnormal" },
            { text: "快楽拷問", type: 7, score: 10, isOni: true, genre: "abnormal" },
            { text: "アヘ顔ダブピ", type: 7, score: 10, isOni: true, genre: "abnormal" },
            { text: "種付けプレス", type: 7, score: 10, isOni: true, genre: "abnormal" },
            { text: "だいしゅきホールド", type: 7, score: 10, isOni: true, genre: "abnormal" },

            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // ■ ネタ (7文字)
            // ━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
            // 通常カード
            { text: "バキバキ童貞", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "うるせぇ!!いこう!!", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "心を燃やせ", type: 7, score: 5, isOni: false, genre: "neta" },
            { text: "計画通り", type: 7, score: 5, isOni: false, genre: "neta" },
            { text: "持っていかれた", type: 7, score: 5, isOni: false, genre: "neta" },
            { text: "駆逐してやる", type: 7, score: 5, isOni: false, genre: "neta" },
            { text: "全米が泣く", type: 7, score: 5, isOni: false, genre: "neta" },
            { text: "オラオラオラ", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "せやかて工藤", type: 7, score: 5, isOni: false, genre: "neta" },
            { text: "領域展開", type: 7, score: 5, isOni: false, genre: "neta" },
            { text: "汚物は消毒", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "ぽこちんフィーバー", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "ぽこちん蹴り上げ", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "スーパーチャット", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "ウホッいい男", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "竿役募集", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "ノンケを喰らう", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "脳が震える", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "まんちん合体", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "法廷で会おう", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "お前を殺す", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "ハーレムの術", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "クララが立ってる", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "立つんだ、ジョー！", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "飛べねえ豚は", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "元気100倍", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "馬並みなのね", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "やってみせろよ", type: 7, score: 6, isOni: false, genre: "neta" },
            { text: "わくわくすっぞ!!", type: 7, score: 6, isOni: false, genre: "neta" },

            // 鬼札
            { text: "まさか・・・暴走!?", type: 7, score: 20, isOni: true, genre: "neta" },
            { text: "童貞を殺す", type: 7, score: 20, isOni: true, genre: "neta" },
            { text: "安西先生", type: 7, score: 20, isOni: true, genre: "neta" },
            { text: "男同士で", type: 7, score: 20, isOni: true, genre: "neta" },

        ];




        // 配札ロジック (Util)
        // 引数で枚数とジャンル配分を指定可能
        function generateHand(count5 = 5, count7 = 7, genreRatios = { normal: 0, abnormal: 10, neta: 0 }) {
            const totalRatio = genreRatios.normal + genreRatios.abnormal + genreRatios.neta;
            if (totalRatio === 0) {
                // デフォルト: 全てabnormal
                genreRatios = { normal: 0, abnormal: 10, neta: 0 };
            }

            // ジャンルに応じて一枚ずつ選ぶ
            const pickOneByGenre = (arr) => {
                const total = genreRatios.normal + genreRatios.abnormal + genreRatios.neta;
                const rand = Math.random() * total;
                let genre;
                if (rand < genreRatios.normal) {
                    genre = "normal";
                } else if (rand < genreRatios.normal + genreRatios.abnormal) {
                    genre = "abnormal";
                } else {
                    genre = "neta";
                }

                // 該当ジャンルのワードをフィルタ
                const candidates = arr.filter(w => w.genre === genre);
                if (candidates.length === 0) {
                    // 該当ジャンルがない場合は全体から
                    return arr[Math.floor(Math.random() * arr.length)];
                }
                return candidates[Math.floor(Math.random() * candidates.length)];
            };

            const pick = (arr, count) => {
                const result = [];
                const used = new Set();
                for (let i = 0; i < count && i < arr.length; i++) {
                    let word;
                    let attempts = 0;
                    do {
                        word = pickOneByGenre(arr);
                        attempts++;
                    } while (used.has(word.text) && attempts < 100);

                    if (!used.has(word.text)) {
                        used.add(word.text);
                        result.push({ ...word, id: Math.random().toString(36).substr(2, 9) });
                    }
                }
                return result;
            };

            const fives = WORD_DICTIONARY.filter(w => w.type === 5);
            const sevens = WORD_DICTIONARY.filter(w => w.type === 7);

            return {
                fives: pick(fives, count5),
                sevens: pick(sevens, count7)
            };
        }

        // 全プレイヤー分の手札を生成（プレイヤー間で重複なし）
        function generateHandsForAllPlayers(playerCount, count5 = 5, count7 = 7, genreRatios = { normal: 0, abnormal: 10, neta: 0 }) {
            const totalRatio = genreRatios.normal + genreRatios.abnormal + genreRatios.neta;
            if (totalRatio === 0) {
                genreRatios = { normal: 0, abnormal: 10, neta: 0 };
            }

            const pickOneByGenre = (available) => {
                const total = genreRatios.normal + genreRatios.abnormal + genreRatios.neta;
                const rand = Math.random() * total;
                let genre;
                if (rand < genreRatios.normal) {
                    genre = "normal";
                } else if (rand < genreRatios.normal + genreRatios.abnormal) {
                    genre = "abnormal";
                } else {
                    genre = "neta";
                }

                const candidates = available.filter(w => w.genre === genre);
                if (candidates.length === 0) {
                    return available[Math.floor(Math.random() * available.length)];
                }
                return candidates[Math.floor(Math.random() * candidates.length)];
            };

            const fivesPool = [...WORD_DICTIONARY.filter(w => w.type === 5)];
            const sevensPool = [...WORD_DICTIONARY.filter(w => w.type === 7)];
            const hands = [];

            for (let p = 0; p < playerCount; p++) {
                const hand = { fives: [], sevens: [] };

                // 5文字カードを配布
                for (let i = 0; i < count5 && fivesPool.length > 0; i++) {
                    const word = pickOneByGenre(fivesPool);
                    const idx = fivesPool.findIndex(w => w.text === word.text);
                    if (idx !== -1) {
                        fivesPool.splice(idx, 1);
                        hand.fives.push({ ...word, id: Math.random().toString(36).substr(2, 9) });
                    }
                }

                // 7文字カードを配布
                for (let i = 0; i < count7 && sevensPool.length > 0; i++) {
                    const word = pickOneByGenre(sevensPool);
                    const idx = sevensPool.findIndex(w => w.text === word.text);
                    if (idx !== -1) {
                        sevensPool.splice(idx, 1);
                        hand.sevens.push({ ...word, id: Math.random().toString(36).substr(2, 9) });
                    }
                }

                hands.push(hand);
            }

            return hands;
        }

        createApp({
            data() {
                return {
                    viewState: 'LOBBY',
                    gamePhase: 'WRITING',

                    myPlayerName: '',
                    roomId: '',
                    myUid: '',

                    players: [],
                    masterHistory: [],
                    roundCount: 1,
                    masterUid: '',

                    gameCount: 1,

                    currentHaikus: [],
                    allGameHaikus: [], // ゲーム全体の俳句（MVP選出用）
                    myDraft: { top: null, middle: null, bottom: null },

                    // 演出用
                    useSpecialEffect: false,
                    showSpecialEffectOverlay: false,
                    specialEffectHaiku: null,
                    specialEffectQueue: [], // 複数の演出用キュー
                    isSpecialEffectDone: false, // 演出再生済みフラグ
                    visiblePhraseIndex: -1, // 読み上げ同期用（-1:非表示, 0:上五, 1:中七, 2:下五）

                    freeInputText: '',
                    freeInputType: 5,

                    isLoading: false,
                    errorMessage: '',

                    visibleResultCount: 0,
                    isResultAnimationDone: false,
                    tempRankState: {},

                    unsubRoom: null,
                    unsubHaikus: null,

                    expandedRecordId: null, // 殿堂入り展開用

                    // 接続安定化用
                    isReconnecting: false,
                    connectionStatus: 'offline',
                    connectionStatus: 'offline',
                    lastError: null,

                    isTestMode: false,

                    // 設定・タイマー
                    settings: {
                        timeLimit: 300, // 秒
                        showMaster: true,
                        showScore: true,
                        likePoints: 10,
                        everyonePlays: false,
                        handSizeFive: 5,
                        handSizeSeven: 5,
                        genreNormal: 0,
                        genreAbnormal: 10,
                        genreNeta: 0,
                        speechEnabled: false // 俳句演出読み上げ
                    },
                    tempSettings: { // 編集用
                        timeLimitMin: 5,
                        showMaster: true,
                        showScore: true,
                        likePoints: 10,
                        everyonePlays: false,
                        handSizeFive: 5,
                        handSizeSeven: 5,
                        genreNormal: 0,
                        genreAbnormal: 10,
                        genreNeta: 0,
                        speechEnabled: false // 俳句演出読み上げ
                    },
                    roundStartTime: null,
                    timeLeft: 0,
                    timerInterval: null
                };
            },
            computed: {
                isMeMaster() { return this.myUid === this.masterUid; },

                myHand() {
                    const p = this.players.find(x => x.uid === this.myUid);
                    return p ? p.hand : { fives: [], sevens: [] };
                },
                hasCreatedFreeCard() {
                    if (!this.myHand) return false;
                    return (this.myHand.fives.some(c => c.isFree) || this.myHand.sevens.some(c => c.isFree));
                },
                currentDraftScore() {
                    let s = 0;
                    if (this.myDraft.top) s += this.myDraft.top.score;
                    if (this.myDraft.middle) s += this.myDraft.middle.score;
                    if (this.myDraft.bottom) s += this.myDraft.bottom.score;
                    return s;
                },
                hasSubmitted() {
                    return this.currentHaikus.some(h => h.userId === this.myUid);
                },
                submittedCount() {
                    return this.currentHaikus.length;
                },
                canFinalize() {
                    if (this.settings.everyonePlays) return true;
                    const ranks = Object.values(this.tempRankState);
                    const needed = Math.min(3, this.currentHaikus.length);
                    return ranks.length >= needed;
                },
                sortedHaikusForJudging() {
                    const list = [...this.currentHaikus];
                    // 演出付きの俳句を先頭にする
                    // かつ、通常はランダム
                    list.sort((a, b) => {
                        if (a.isSpecial && !b.isSpecial) return -1;
                        if (!a.isSpecial && b.isSpecial) return 1;
                        // 両方Special or 両方Normalならランダムキーでソート
                        return (a.randomSortKey || 0) - (b.randomSortKey || 0);
                    });
                    return list;
                },
                sortedHaikusForDisplay() {
                    const hasRanks = this.currentHaikus.some(h => h.rank && h.rank > 0);
                    if (this.settings.everyonePlays || !hasRanks) {
                        const sorted = [...this.currentHaikus].sort((a, b) => (b.totalScore || 0) - (a.totalScore || 0));
                        return sorted.map((h, i) => ({ ...h, _virtualRank: i + 1 }));
                    }
                    return [...this.currentHaikus].sort((a, b) => (a.rank || 999) - (b.rank || 999));
                },
                sortedPlayers() {
                    if (this.settings.showScore) {
                        return [...this.players].sort((a, b) => b.score - a.score);
                    }
                    return this.players;
                },
                // 自分がいいねを既にしているか（1回制限チェック用）
                hasLikedAny() {
                    return this.currentHaikus.some(h => h.likes && h.likes.includes(this.myUid));
                },
                likedCount() {
                    const uids = new Set();
                    this.currentHaikus.forEach(h => {
                        if (h.likes) {
                            h.likes.forEach(uid => uids.add(uid));
                        }
                    });
                    return uids.size;
                },
                likeTargetCount() {
                    return this.settings.everyonePlays ? this.players.length : (this.players.length - 1);
                },

                hasMySpecialEffectUsed() {
                    if (!this.myUid) return false;
                    const p = this.players.find(p => p.uid === this.myUid);
                    return p ? !!p.specialEffectUsed : false;
                },

                // 全ラウンド通してのMVP俳句（いいね数順 -> 点数順）
                topLikedHaikus() {
                    if (!this.allGameHaikus || this.allGameHaikus.length === 0) return [];

                    // 現在のゲーム(gameCount)の俳句のみ対象
                    const target = this.allGameHaikus.filter(h => h.gameCount === this.gameCount);

                    // ソート: いいね数(降順) > 点数(降順)
                    return target.sort((a, b) => {
                        const likeA = a.likes ? a.likes.length : 0;
                        const likeB = b.likes ? b.likes.length : 0;
                        if (likeA !== likeB) return likeB - likeA;
                        return (b.totalScore || 0) - (a.totalScore || 0);
                    }).slice(0, 3); // 上位3つ
                }
            },

            // ページ読み込み時に自動復帰を試みる
            async mounted() {
                await this.tryAutoReconnect();
            },

            methods: {
                // --- セッション管理 ---
                saveSession() {
                    const sessionData = {
                        roomId: this.roomId,
                        playerName: this.myPlayerName,
                        uid: this.myUid,
                        isTestMode: this.isTestMode,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('haikuGameSession', JSON.stringify(sessionData));
                },

                loadSession() {
                    try {
                        const saved = localStorage.getItem('haikuGameSession');
                        if (!saved) return null;
                        const session = JSON.parse(saved);
                        // 24時間以内のセッションのみ有効
                        if (Date.now() - session.timestamp > 24 * 60 * 60 * 1000) {
                            localStorage.removeItem('haikuGameSession');
                            return null;
                        }
                        return session;
                    } catch (e) {
                        return null;
                    }
                },

                clearSession() {
                    localStorage.removeItem('haikuGameSession');
                },

                // --- 自動復帰（ページリロード対応） ---
                async tryAutoReconnect() {
                    const session = this.loadSession();
                    if (!session) return false;

                    this.isReconnecting = true;
                    this.connectionStatus = 'reconnecting';

                    try {
                        // Firebase認証状態を確認・復帰
                        const userCred = await signInAnonymously(auth);
                        this.myUid = userCred.user.uid;

                        // 部屋が存在するか確認
                        const roomRef = doc(db, "rooms", session.roomId);
                        const roomSnap = await getDoc(roomRef);

                        if (roomSnap.exists()) {
                            const data = roomSnap.data();
                            // 自分がまだ部屋にいるか確認（UIDまたは名前で照合）
                            let myPlayer = data.players.find(p => p.uid === session.uid);
                            if (!myPlayer) {
                                myPlayer = data.players.find(p => p.name === session.playerName);
                            }

                            if (myPlayer) {
                                this.roomId = session.roomId;
                                this.myPlayerName = myPlayer.name;
                                this.myUid = myPlayer.uid;
                                this.isTestMode = session.isTestMode || false;

                                // セッション更新
                                this.saveSession();

                                this.startRoomListener();
                                this.viewState = 'GAME';
                                this.connectionStatus = 'online';
                                this.isReconnecting = false;
                                console.log('セッション復帰成功');
                                return true;
                            }
                        }
                    } catch (e) {
                        console.warn('自動復帰失敗:', e);
                    }

                    this.isReconnecting = false;
                    this.connectionStatus = 'offline';
                    this.clearSession();
                    return false;
                },

                // ロビー機能
                hallOfFameList: [],

                // ロビー機能 --- 
                async enterRoom() {
                    if (!db) { this.errorMessage = "Firebase設定がありません"; return; }
                    this.isLoading = true;
                    this.errorMessage = '';
                    this.lastError = null;

                    try {
                        const userCred = await signInAnonymously(auth);
                        this.myUid = userCred.user.uid;

                        const roomRef = doc(db, "rooms", this.roomId);
                        const roomSnap = await getDoc(roomRef);

                        const initialHand = generateHand();
                        const newPlayer = {
                            uid: this.myUid,
                            name: this.myPlayerName,
                            score: 0,
                            totalLikes: 0,
                            winCount: 0, // 優勝回数初期化
                            hand: initialHand
                        };

                        if (!roomSnap.exists()) {
                            // 新規作成
                            await setDoc(roomRef, {
                                roomId: this.roomId,
                                status: 'WAITING', // 待機状態からスタート
                                gameCount: 1,
                                roundCount: 1,
                                masterUid: this.myUid,
                                masterHistory: [this.myUid],
                                players: [newPlayer],
                                settings: {
                                    timeLimit: 300,
                                    showMaster: true,
                                    showScore: true,
                                    likePoints: 10,
                                    everyonePlays: false,
                                    handSizeFive: 5, // 5文字カード枚数
                                    handSizeSeven: 5  // 7文字カード枚数
                                },
                                roundStartTime: null
                            });
                        } else {
                            // 参加
                            const data = roomSnap.data();
                            const existing = data.players.find(p => p.uid === this.myUid);
                            if (!existing) {
                                await updateDoc(roomRef, {
                                    players: arrayUnion(newPlayer)
                                });
                            }
                        }

                        // セッション保存
                        this.saveSession();
                        this.connectionStatus = 'online';

                        this.startRoomListener();
                        // viewStateはリスナーのstatusを見て更新されるのでここでは仮設定しない、
                        // またはWAITINGとしておく
                        this.viewState = 'WAITING';

                    } catch (e) {
                        console.error(e);
                        this.errorMessage = "エラー: " + e.message;
                        this.lastError = e;
                        this.connectionStatus = 'offline';
                    } finally {
                        this.isLoading = false;
                    }
                },

                // --- Firestore監視（リスナー重複防止付き） ---
                startRoomListener() {
                    // 既存のリスナーがあれば解除（重複防止）
                    if (this.unsubRoom) {
                        this.unsubRoom();
                        this.unsubRoom = null;
                    }
                    if (this.unsubHaikus) {
                        this.unsubHaikus();
                        this.unsubHaikus = null;
                    }

                    // Room監視
                    this.unsubRoom = onSnapshot(doc(db, "rooms", this.roomId), (docSnap) => {
                        if (!docSnap.exists()) return;
                        const data = docSnap.data();

                        this.players = data.players || [];
                        this.roundCount = data.roundCount;
                        this.masterUid = data.masterUid;
                        this.masterHistory = data.masterHistory || [];
                        this.gameCount = data.gameCount || 1;
                        this.connectionStatus = 'online';
                        this.roundStartTime = data.roundStartTime || null;

                        console.log('Room update:', data); // DEBUG
                        console.log('Current Phase:', this.gamePhase, 'New Status:', data.status); // DEBUG

                        // 設定同期
                        if (data.settings) {
                            this.settings = {
                                timeLimit: 300,
                                showMaster: true,
                                showScore: true,
                                likePoints: 10,
                                everyonePlays: false,
                                ...data.settings
                            };
                            // 編集用変数にも反映（自分がホストで編集中でない場合...は難しいので、とりあえず同期）
                            // 自分が編集中の場合、ループしないように少し工夫が必要だが、
                            // 今回は単純に同期する（他人が変えることはない前提）
                            if (!this.isMeMaster) {
                                // 閲覧者は常にDBの値を見る
                            } else {
                                // ホストもDBの値が正だが、UI入力用に変換
                                // ※入力中はここが頻繁に更新されると使いにくいが、
                                // DB更新はchangeイベントで行うので、そこまで競合しない
                                // this.tempSettings.timeLimitMin = Math.floor(this.settings.timeLimit / 60);
                                // this.tempSettings.showMaster = this.settings.showMaster;
                                // this.tempSettings.likePoints = this.settings.likePoints;
                            }
                        }

                        // ステータス変化検知
                        if (this.gamePhase !== data.status) {
                            const oldPhase = this.gamePhase;
                            this.gamePhase = data.status;

                            if (this.gamePhase === 'FINISHED') {
                                this.viewState = 'FINISHED';
                            } else if (this.gamePhase === 'WAITING') {
                                this.viewState = 'WAITING';
                                // ロビーに戻ったらtempSettingsも初期化
                                if (this.settings) {
                                    this.tempSettings.timeLimitMin = Math.floor(this.settings.timeLimit / 60);
                                    this.tempSettings.showMaster = this.settings.showMaster;
                                    this.tempSettings.showScore = this.settings.showScore;
                                    this.tempSettings.likePoints = this.settings.likePoints;
                                    this.tempSettings.everyonePlays = this.settings.everyonePlays;
                                    this.tempSettings.handSizeFive = this.settings.handSizeFive || 5;
                                    this.tempSettings.handSizeSeven = this.settings.handSizeSeven || 5;
                                    this.tempSettings.genreNormal = this.settings.genreNormal || 0;
                                    this.tempSettings.genreAbnormal = this.settings.genreAbnormal || 10;
                                    this.tempSettings.genreNeta = this.settings.genreNeta || 0;
                                    this.tempSettings.speechEnabled = this.settings.speechEnabled || false;
                                }
                            } else {
                                this.viewState = 'GAME';
                            }

                            if (this.gamePhase === 'WRITING') {
                                this.myDraft = { top: null, middle: null, bottom: null };
                                this.isResultAnimationDone = false;
                                this.tempRankState = {};
                                this.isSpecialEffectDone = false; // フラグ初期化
                                // タイマー開始
                                this.startTimer();
                            } else if (this.gamePhase === 'JUDGING') {
                                this.stopTimer();
                                // 演出判定
                                // 少し待ってから俳句リストを確認（同期ズレ対策）
                                setTimeout(() => {
                                    if (!this.isSpecialEffectDone) {
                                        this.processSpecialEffects();
                                    }
                                }, 1000);
                            } else {
                                this.stopTimer();
                            }

                            if (this.gamePhase === 'RESULT') {
                                this.playResultAnimation();
                            }
                        } else {
                            // フェーズが変わらなくても時刻同期などでタイマー調整が必要かも
                            if (this.gamePhase === 'WRITING') {
                                this.startTimer();
                            }
                        }
                    }, (error) => {
                        console.error('Room listener error:', error);
                        this.connectionStatus = 'offline';
                        this.lastError = error;
                    });

                    // 俳句監視
                    const haikusRef = collection(db, "rooms", this.roomId, "haikus");
                    this.unsubHaikus = onSnapshot(haikusRef, (snapshot) => {
                        const allHaikus = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));

                        // 全俳句を保持（MVP用）
                        this.allGameHaikus = allHaikus;

                        this.currentHaikus = allHaikus.filter(h =>
                            h.gameCount === this.gameCount &&
                            h.round === this.roundCount
                        );

                        // 自動進行チェック
                        const isMasterNPC = this.masterUid && this.masterUid.startsWith('npc-');
                        if ((this.isMeMaster || isMasterNPC) && this.gamePhase === 'WRITING') {
                            const writers = this.settings.everyonePlays
                                ? this.players
                                : this.players.filter(p => p.uid !== this.masterUid);
                            if (writers.length > 0 && this.currentHaikus.length >= writers.length) {
                                updateDoc(doc(db, "rooms", this.roomId), { status: 'JUDGING' });
                            }
                        }
                    }, (error) => {
                        console.error('Haikus listener error:', error);
                    });
                },

                processSpecialEffects() {
                    const specials = this.currentHaikus.filter(h => h.isSpecial);
                    if (specials.length > 0) {
                        // ランダムキー順などでソート済みであることを期待するなら currentHaikus の順序に従う
                        // 演出用にキューに入れる
                        this.specialEffectQueue = [...specials];
                        this.isSpecialEffectDone = true; // 再生開始フラグ
                        this.playNextSpecialEffect();
                    }
                },

                playNextSpecialEffect() {
                    if (this.specialEffectQueue.length === 0) {
                        this.showSpecialEffectOverlay = false;
                        this.specialEffectHaiku = null;
                        this.visiblePhraseIndex = -1;
                        return;
                    }

                    const next = this.specialEffectQueue.shift();
                    this.specialEffectHaiku = next;
                    this.showSpecialEffectOverlay = true;
                    this.visiblePhraseIndex = -1; // 表示リセット

                    // 演出終了処理
                    const endEffect = () => {
                        this.showSpecialEffectOverlay = false;
                        this.visiblePhraseIndex = -1;

                        // 少し間隔を空けて次
                        if (this.specialEffectQueue.length > 0) {
                            setTimeout(() => {
                                this.playNextSpecialEffect();
                            }, 500); // 0.5秒間隔
                        } else {
                            this.specialEffectHaiku = null;
                        }
                    };

                    // 音声読み上げが有効な場合
                    if (this.settings.speechEnabled) {
                        this.speakHaiku(next, endEffect);
                    } else {
                        // 読み上げ無効時は順次表示のみ
                        this.showPhrasesSequentially(endEffect);
                    }
                },

                // --- 俳句読み上げ ---
                speakHaiku(haiku, onComplete) {
                    if (!window.speechSynthesis) {
                        console.warn('Speech Synthesis not supported');
                        // 読み上げ無効でも表示は順次行う
                        this.showPhrasesSequentially(onComplete);
                        return;
                    }

                    // 読み上げ中のものをキャンセル
                    window.speechSynthesis.cancel();

                    // 表示リセット
                    this.visiblePhraseIndex = -1;

                    // ❤記号を除去
                    const cleanText = (text) => text.replace(/[❤️❤]/g, '').trim();

                    const top = cleanText(haiku.top.text);
                    const middle = cleanText(haiku.middle.text);
                    const bottom = cleanText(haiku.bottom.text);
                    const parts = [top, middle, bottom];

                    // 順番に読み上げる（前のパートが終わったら次を読む）
                    let index = 0;
                    const self = this;

                    const speakNext = () => {
                        if (index >= parts.length) {
                            // 全パート読み上げ完了、1秒後にコールバック
                            if (onComplete) {
                                setTimeout(onComplete, 1000);
                            }
                            return;
                        }

                        // 表示を先行（読み上げ開始の少し前に表示）
                        self.visiblePhraseIndex = index;

                        // 少し遅らせてから読み上げ開始
                        setTimeout(() => {
                            const utterance = new SpeechSynthesisUtterance(parts[index]);
                            utterance.lang = 'ja-JP';
                            utterance.rate = 0.85; // 少しゆっくり
                            utterance.pitch = 1.0;
                            utterance.onend = () => {
                                index++;
                                // 次のパートまで少し間を空ける
                                setTimeout(speakNext, 100);
                            };
                            window.speechSynthesis.speak(utterance);
                        }, 100); // 表示から100ms後に読み上げ開始
                    };

                    // 最初のパートを少し遅らせてから開始
                    setTimeout(speakNext, 100);
                },

                // 読み上げ無効時の順次表示
                showPhrasesSequentially(onComplete) {
                    this.visiblePhraseIndex = -1;
                    setTimeout(() => { this.visiblePhraseIndex = 0; }, 300);
                    setTimeout(() => { this.visiblePhraseIndex = 1; }, 1300);
                    setTimeout(() => { this.visiblePhraseIndex = 2; }, 1300);
                    // 最後の表示から1.5秒後にコールバック
                    if (onComplete) {
                        setTimeout(onComplete, 3800);
                    }
                },

                // --- UI表示用クラス ---
                getCardClass(card) {
                    return {
                        oni: card.isOni,
                        free: card.isFree,
                        selected: this.isCardSelected(card)
                    };
                },
                getSlotClass(card) {
                    if (!card) return {};
                    return { filled: true, oni: card.isOni, free: card.isFree };
                },

                // --- 詠唱アクション ---
                isCardSelected(card) {
                    const d = this.myDraft;
                    return (d.top && d.top.id === card.id) ||
                        (d.middle && d.middle.id === card.id) ||
                        (d.bottom && d.bottom.id === card.id);
                },
                selectFive(card) {
                    if (!this.myDraft.top) this.myDraft.top = card;
                    else if (!this.myDraft.bottom) this.myDraft.bottom = card;
                    else this.myDraft.top = card;
                },
                selectSeven(card) {
                    this.myDraft.middle = card;
                },
                removePart(part) {
                    this.myDraft[part] = null;
                },

                // --- 自由記入追加 ---
                async addFreeCard() {
                    if (!this.freeInputText) return;

                    const newCard = {
                        id: 'free-' + Date.now(),
                        text: this.freeInputText,
                        type: this.freeInputType,
                        score: 4,
                        isOni: false,
                        isFree: true
                    };

                    const myIdx = this.players.findIndex(p => p.uid === this.myUid);
                    if (myIdx === -1) return;

                    const updatedPlayers = [...this.players];
                    const myHand = { ...updatedPlayers[myIdx].hand };

                    if (this.freeInputType === 5) {
                        myHand.fives = [newCard, ...myHand.fives];
                    } else {
                        myHand.sevens = [newCard, ...myHand.sevens];
                    }

                    updatedPlayers[myIdx].hand = myHand;

                    await updateDoc(doc(db, "rooms", this.roomId), { players: updatedPlayers });
                    this.freeInputText = '';
                },

                // --- リセット ---
                async resetDraft() {
                    let needDbUpdate = false;
                    const myIdx = this.players.findIndex(p => p.uid === this.myUid);
                    if (myIdx === -1) {
                        this.myDraft = { top: null, middle: null, bottom: null };
                        return;
                    }

                    let updatedPlayers = [...this.players];
                    let myHand = { ...updatedPlayers[myIdx].hand };

                    // 手札内の自由記入カードを全て削除
                    const originalFivesCount = myHand.fives.length;
                    const originalSevensCount = myHand.sevens.length;

                    myHand.fives = myHand.fives.filter(c => !c.isFree);
                    myHand.sevens = myHand.sevens.filter(c => !c.isFree);

                    if (myHand.fives.length !== originalFivesCount || myHand.sevens.length !== originalSevensCount) {
                        needDbUpdate = true;
                    }

                    if (needDbUpdate) {
                        updatedPlayers[myIdx].hand = myHand;
                        await updateDoc(doc(db, "rooms", this.roomId), { players: updatedPlayers });
                    }

                    this.myDraft = { top: null, middle: null, bottom: null };
                },

                async submitHaiku() {
                    if (!this.myDraft.top) return;
                    const cardScore = this.myDraft.top.score + this.myDraft.middle.score + this.myDraft.bottom.score;

                    // 重複提出防止のため、ユーザーIDとラウンド情報をキーにしたIDを生成
                    const haikuId = `${this.gameCount}_${this.roundCount}_${this.myUid}`;

                    const isSpecial = this.useSpecialEffect && !this.hasMySpecialEffectUsed;

                    await setDoc(doc(db, "rooms", this.roomId, "haikus", haikuId), {
                        userId: this.myUid,
                        top: this.myDraft.top,
                        middle: this.myDraft.middle,
                        bottom: this.myDraft.bottom,
                        gameCount: this.gameCount,
                        round: this.roundCount,
                        rank: 0,
                        likes: [],
                        cardScore: cardScore,
                        bonusScore: 0,
                        totalScore: 0,
                        randomSortKey: Math.random(),
                        isSpecial: isSpecial // 演出フラグ
                    });

                    // 演出を使用した場合はプレイヤー情報を更新
                    if (isSpecial) {
                        const myIdx = this.players.findIndex(p => p.uid === this.myUid);
                        if (myIdx !== -1) {
                            const updatedPlayers = [...this.players];
                            updatedPlayers[myIdx].specialEffectUsed = true;
                            await updateDoc(doc(db, "rooms", this.roomId), { players: updatedPlayers });
                        }
                    }

                    // 提出したらフラグ戻す
                    this.useSpecialEffect = false;
                },

                // --- 強制進行 ---
                async forceAllSubmit() {
                    const batch = writeBatch(db);
                    const haikusRef = collection(db, "rooms", this.roomId, "haikus");

                    const unsubmittedPlayers = this.players.filter(p => {
                        if (!this.settings.everyonePlays && p.uid === this.masterUid) return false;
                        return !this.currentHaikus.find(h => h.userId === p.uid);
                    });

                    unsubmittedPlayers.forEach(p => {
                        const topCands = p.hand.fives.filter(c => !c.isFree);
                        const top = topCands[Math.floor(Math.random() * topCands.length)];

                        const midCands = p.hand.sevens.filter(c => !c.isFree);
                        const middle = midCands[Math.floor(Math.random() * midCands.length)];

                        const botCands = topCands.filter(c => c.id !== top.id);
                        const bottom = botCands.length > 0 ? botCands[Math.floor(Math.random() * botCands.length)] : top;

                        const cardScore = top.score + middle.score + bottom.score;

                        const haikuId = `${this.gameCount}_${this.roundCount}_${p.uid}`;
                        const newDocRef = doc(haikusRef, haikuId);
                        batch.set(newDocRef, {
                            userId: p.uid,
                            top, middle, bottom,
                            gameCount: this.gameCount,
                            round: this.roundCount,
                            rank: 0, likes: [], cardScore, bonusScore: 0, totalScore: 0,
                            randomSortKey: Math.random()
                        });
                    });

                    await batch.commit();
                    setTimeout(() => {
                        updateDoc(doc(db, "rooms", this.roomId), { status: 'JUDGING' });
                    }, 500);
                },

                // --- 選評アクション ---
                setRank(haiku, rank) {
                    for (const [hid, r] of Object.entries(this.tempRankState)) {
                        if (r === rank) delete this.tempRankState[hid];
                    }
                    this.tempRankState[haiku.id] = rank;
                },

                async toggleLike(haiku) {
                    const haikuRef = doc(db, "rooms", this.roomId, "haikus", haiku.id);
                    const isLiked = haiku.likes && haiku.likes.includes(this.myUid);

                    if (isLiked) {
                        const newLikes = haiku.likes.filter(uid => uid !== this.myUid);
                        await updateDoc(haikuRef, { likes: newLikes });
                    } else {
                        await updateDoc(haikuRef, { likes: arrayUnion(this.myUid) });
                    }
                },

                async finalizeJudging() {
                    const batch = writeBatch(db);
                    const roomRef = doc(db, "rooms", this.roomId);

                    const scoreUpdates = {};
                    const likeUpdates = {};
                    this.players.forEach(p => { scoreUpdates[p.uid] = 0; likeUpdates[p.uid] = 0; });

                    for (const h of this.currentHaikus) {
                        const rank = this.tempRankState[h.id] || 0;

                        let rankScore = 0;
                        if (!this.settings.everyonePlays) {
                            if (rank === 1) rankScore = 100;
                            else if (rank === 2) rankScore = 60;
                            else if (rank === 3) rankScore = 20;
                        }

                        const likeCount = h.likes ? h.likes.length : 0;
                        const likeScore = likeCount * this.settings.likePoints;
                        const bonusScore = rankScore + likeScore;
                        const totalScore = (h.cardScore || 0) + bonusScore;

                        const hRef = doc(db, "rooms", this.roomId, "haikus", h.id);
                        batch.update(hRef, { rank, bonusScore, totalScore });

                        if (scoreUpdates[h.userId] !== undefined) {
                            scoreUpdates[h.userId] += totalScore;
                            likeUpdates[h.userId] += likeCount;
                        }
                    }

                    const newPlayers = this.players.map(p => {
                        return {
                            ...p,
                            score: p.score + (scoreUpdates[p.uid] || 0),
                            totalLikes: (p.totalLikes || 0) + (likeUpdates[p.uid] || 0)
                        };
                    });

                    batch.update(roomRef, { players: newPlayers, status: 'RESULT' });

                    await batch.commit();
                },

                // 強制進行（いいね未完了でも結果発表へ進む）
                async forceFinalize() {
                    const batch = writeBatch(db);
                    const roomRef = doc(db, "rooms", this.roomId);

                    const scoreUpdates = {};
                    const likeUpdates = {};
                    this.players.forEach(p => { scoreUpdates[p.uid] = 0; likeUpdates[p.uid] = 0; });

                    for (const h of this.currentHaikus) {
                        const rank = this.tempRankState[h.id] || 0;

                        let rankScore = 0;
                        if (rank === 1) rankScore = 100;
                        else if (rank === 2) rankScore = 60;
                        else if (rank === 3) rankScore = 20;

                        const likeCount = h.likes ? h.likes.length : 0;
                        const likeScore = likeCount * this.settings.likePoints;
                        const bonusScore = rankScore + likeScore;
                        const totalScore = (h.cardScore || 0) + bonusScore;

                        const hRef = doc(db, "rooms", this.roomId, "haikus", h.id);
                        batch.update(hRef, { rank, bonusScore, totalScore });

                        if (scoreUpdates[h.userId] !== undefined) {
                            scoreUpdates[h.userId] += totalScore;
                            likeUpdates[h.userId] += likeCount;
                        }
                    }

                    const newPlayers = this.players.map(p => {
                        return {
                            ...p,
                            score: p.score + (scoreUpdates[p.uid] || 0),
                            totalLikes: (p.totalLikes || 0) + (likeUpdates[p.uid] || 0)
                        };
                    });

                    batch.update(roomRef, { players: newPlayers, status: 'RESULT' });

                    await batch.commit();
                },

                getHaikuCardScore(haiku) {
                    return haiku.top.score + haiku.middle.score + haiku.bottom.score;
                },
                getRankScore(rank) {
                    if (rank === 1) return 100;
                    if (rank === 2) return 60;
                    if (rank === 3) return 20;
                    return 0;
                },

                playResultAnimation() {
                    let count = 0;
                    const total = this.currentHaikus.length || 0;
                    this.visibleResultCount = 0;
                    const interval = setInterval(() => {
                        count++;
                        this.visibleResultCount = count;
                        if (count >= total) {
                            clearInterval(interval);
                            this.isResultAnimationDone = true;
                        }
                    }, 1500);
                },

                // --- ゲーム進行・設定 ---
                async saveSettings() {
                    if (!this.isMeMaster) return;
                    // tempSettings -> settings -> DB
                    const newSettings = {
                        timeLimit: this.tempSettings.timeLimitMin * 60,
                        showMaster: this.tempSettings.showMaster,
                        showScore: this.tempSettings.showScore,
                        likePoints: this.tempSettings.likePoints,
                        everyonePlays: this.tempSettings.everyonePlays,
                        handSizeFive: this.tempSettings.handSizeFive,
                        handSizeSeven: this.tempSettings.handSizeSeven,
                        genreNormal: this.tempSettings.genreNormal,
                        genreAbnormal: this.tempSettings.genreAbnormal,
                        genreNeta: this.tempSettings.genreNeta,
                        speechEnabled: this.tempSettings.speechEnabled
                    };
                    await updateDoc(doc(db, "rooms", this.roomId), { settings: newSettings });
                },

                async startGame() {
                    // Start Gameボタン
                    try {
                        // 開始時に設定を保存して確実にする
                        await this.saveSettings();

                        console.log('Starting game for room:', this.roomId);

                        // 親をランダムに選出
                        const randomIdx = Math.floor(Math.random() * this.players.length);
                        const nextMasterUid = this.players[randomIdx].uid;

                        // 設定に合わせて手札を配り直す（プレイヤー間で重複なし）
                        const genreRatios = {
                            normal: this.tempSettings.genreNormal || 0,
                            abnormal: this.tempSettings.genreAbnormal || 10,
                            neta: this.tempSettings.genreNeta || 0
                        };
                        const allHands = generateHandsForAllPlayers(
                            this.players.length,
                            this.tempSettings.handSizeFive,
                            this.tempSettings.handSizeSeven,
                            genreRatios
                        );
                        const refreshedPlayers = this.players.map((p, idx) => {
                            return {
                                ...p,
                                hand: allHands[idx]
                            };
                        });

                        await updateDoc(doc(db, "rooms", this.roomId), {
                            status: 'WRITING',
                            roundStartTime: Date.now(),
                            masterUid: nextMasterUid,
                            masterHistory: [nextMasterUid],
                            players: refreshedPlayers
                        });
                        console.log('Game status updated to WRITING');
                    } catch (e) {
                        console.error('Error starting game:', e);
                        alert('ゲーム開始エラー: ' + e.message);
                    }
                },

                startTimer() {
                    if (this.timerInterval) clearInterval(this.timerInterval);
                    this.updateTime();
                    this.timerInterval = setInterval(() => {
                        this.updateTime();
                    }, 1000);
                },
                stopTimer() {
                    if (this.timerInterval) clearInterval(this.timerInterval);
                    this.timerInterval = null;
                    this.timeLeft = 0;
                },
                updateTime() {
                    if (!this.roundStartTime || this.gamePhase !== 'WRITING') {
                        this.timeLeft = 0;
                        return;
                    }
                    const elapsed = (Date.now() - this.roundStartTime) / 1000;
                    const limit = this.settings.timeLimit;
                    const remain = limit - elapsed;

                    if (remain <= 0) {
                        this.timeLeft = 0;
                        // 親であれば強制実行
                        if (this.isMeMaster && this.gamePhase === 'WRITING') {
                            // 連打防止のため、すでに処理中ならスキップしたいが...
                            // forceAllSubmit内でbatch処理するのである程度安全。
                            // ただし短時間に何度も呼ばれると困る
                            this.forceAllSubmit();
                        }
                    } else {
                        this.timeLeft = Math.floor(remain);
                    }
                },

                async nextRound() {
                    if (this.roundCount >= this.players.length) {
                        // ゲーム終了時、優勝者のカウントを加算
                        const sorted = [...this.players].sort((a, b) => b.score - a.score);
                        const topScore = sorted.length > 0 ? sorted[0].score : -999;

                        // 全員のwinCountを更新
                        const updatedPlayers = this.players.map(p => {
                            if (p.score === topScore && topScore > 0) { // 0点の場合は優勝とみなさない等は好みだが、ここでは単純に最高得点
                                return { ...p, winCount: (p.winCount || 0) + 1 };
                            }
                            return p;
                        });

                        await updateDoc(doc(db, "rooms", this.roomId), {
                            status: 'FINISHED',
                            players: updatedPlayers
                        });
                    } else {
                        // 次の親を決定（順番に回す）
                        // ※単純に roundCount % length だと、ゲーム2回目以降におかしくなる可能性があるため、
                        // 「ゲーム開始時の親」を基準にシフトさせるか、単にインデックスを回す。
                        // 今回はシンプルに (現在の親インデックス + 1) % 人数 で計算する。

                        const currentMasterIdx = this.players.findIndex(p => p.uid === this.masterUid);
                        let nextMasterIdx = 0;
                        if (currentMasterIdx !== -1) {
                            nextMasterIdx = (currentMasterIdx + 1) % this.players.length;
                        }

                        const nextMasterUid = this.players[nextMasterIdx].uid;

                        const genreRatios = {
                            normal: this.settings.genreNormal || 0,
                            abnormal: this.settings.genreAbnormal || 10,
                            neta: this.settings.genreNeta || 0
                        };
                        const allHands = generateHandsForAllPlayers(
                            this.players.length,
                            this.settings.handSizeFive,
                            this.settings.handSizeSeven,
                            genreRatios
                        );
                        const refreshedPlayers = this.players.map((p, idx) => {
                            return { ...p, hand: allHands[idx] };
                        });

                        const newHistory = [...this.masterHistory];
                        if (!newHistory.includes(nextMasterUid)) newHistory.push(nextMasterUid);

                        await updateDoc(doc(db, "rooms", this.roomId), {
                            roundCount: increment(1),
                            masterUid: nextMasterUid,
                            masterHistory: newHistory,
                            status: 'WRITING',
                            players: refreshedPlayers,
                            roundStartTime: Date.now()
                        });
                    }
                },

                async startNextGame() {
                    // 次のゲームの設定のためロビーに戻る
                    const genreRatios = {
                        normal: this.settings.genreNormal || 0,
                        abnormal: this.settings.genreAbnormal || 10,
                        neta: this.settings.genreNeta || 0
                    };
                    const allHands = generateHandsForAllPlayers(
                        this.players.length,
                        this.settings.handSizeFive,
                        this.settings.handSizeSeven,
                        genreRatios
                    );
                    const resetPlayers = this.players.map((p, idx) => ({
                        ...p,
                        score: 0,
                        totalLikes: 0,
                        // winCountは維持される(pに含まれるため)
                        hand: allHands[idx]
                    }));
                    const firstMaster = resetPlayers[0].uid;

                    await updateDoc(doc(db, "rooms", this.roomId), {
                        players: resetPlayers,
                        gameCount: increment(1),
                        roundCount: 1,
                        masterUid: firstMaster,
                        masterHistory: [firstMaster],
                        status: 'WAITING', // ロビーへ
                        roundStartTime: null
                    });
                },

                async leaveRoom() {
                    // Firestoreからプレイヤー削除処理
                    if (this.roomId && this.myUid) {
                        try {
                            const roomRef = doc(db, "rooms", this.roomId);
                            const roomSnap = await getDoc(roomRef);
                            if (roomSnap.exists()) {
                                const data = roomSnap.data();
                                // 自分のUIDを除外したプレイヤーリストを作成
                                const newPlayers = data.players.filter(p => p.uid !== this.myUid);
                                await updateDoc(roomRef, { players: newPlayers });
                            }
                        } catch (e) {
                            console.error('Leave room error:', e);
                        }
                    }

                    if (this.unsubRoom) this.unsubRoom();
                    if (this.unsubHaikus) this.unsubHaikus();
                    this.clearSession();
                    this.viewState = 'LOBBY';
                    this.roomId = '';
                    this.currentHaikus = [];
                },

                // ルーム情報を完全にリセット（削除）
                async resetRoom() {
                    if (!this.roomId) {
                        this.errorMessage = 'ルーム番号を入力してください';
                        return;
                    }

                    const confirmed = confirm(`ルーム ${this.roomId} の情報を完全に削除します。よろしいですか？`);
                    if (!confirmed) return;

                    this.isLoading = true;
                    this.errorMessage = '';

                    try {
                        // リスナーを解除
                        if (this.unsubRoom) this.unsubRoom();
                        if (this.unsubHaikus) this.unsubHaikus();

                        const roomRef = doc(db, "rooms", this.roomId);

                        // サブコレクション（俳句）を削除
                        const haikusRef = collection(db, "rooms", this.roomId, "haikus");
                        const haikusSnapshot = await getDocs(haikusRef);
                        const batch = writeBatch(db);

                        haikusSnapshot.forEach((docSnap) => {
                            batch.delete(docSnap.ref);
                        });

                        // ルームドキュメントを削除
                        batch.delete(roomRef);

                        await batch.commit();

                        // ローカル状態をリセット
                        this.clearSession();
                        this.viewState = 'LOBBY';
                        this.currentHaikus = [];
                        this.players = [];
                        this.masterHistory = [];
                        this.roundCount = 1;
                        this.gameCount = 1;
                        this.viewState = 'LOBBY';
                        this.currentHaikus = [];
                        this.players = [];
                        this.masterHistory = [];
                        this.roundCount = 1;
                        this.gameCount = 1;
                        this.gamePhase = 'WRITING';
                        this.stopTimer();

                        alert(`ルーム ${this.roomId} を削除しました。`);
                        this.roomId = '';
                    } catch (e) {
                        console.error('Room reset error:', e);
                        this.errorMessage = 'リセットに失敗しました: ' + e.message;
                    } finally {
                        this.isLoading = false;
                    }
                },

                getMasterName() {
                    const p = this.players.find(p => p.uid === this.masterUid);
                    return p ? p.name : '不明';
                },
                getPlayerName(uid) {
                    const p = this.players.find(p => p.uid === uid);
                    return p ? p.name : '不明';
                },
                hasBeenMaster(uid) {
                    return this.masterHistory.includes(uid);
                },

                // --- デバッグ用機能 ---
                // --- デバッグ用機能 ---
                switchPlayer(uid) {
                    this.myUid = uid;
                    const p = this.players.find(x => x.uid === uid);
                    if (p) this.myPlayerName = p.name;
                },
                async add3NPCs() {
                    if (!this.roomId) return;
                    const npcNames = ['NPC一茶', 'NPC蕪村', 'NPC子規'];
                    const newPlayers = [];
                    for (let i = 0; i < 3; i++) {
                        const npcId = 'npc-' + Math.random().toString(36).substr(2, 5);
                        newPlayers.push({
                            uid: npcId,
                            name: npcNames[i],
                            score: 0,
                            totalLikes: 0,
                            winCount: 0,
                            hand: generateHand(this.settings.handSizeFive, this.settings.handSizeSeven)
                        });
                    }
                    await updateDoc(doc(db, "rooms", this.roomId), { players: arrayUnion(...newPlayers) });
                },

                async npcMasterJudge() {
                    const roomRef = doc(db, "rooms", this.roomId);
                    const candidates = [...this.currentHaikus].sort(() => 0.5 - Math.random());

                    const tempRanks = {};
                    candidates.forEach((h, i) => {
                        if (i === 0) tempRanks[h.id] = 1;
                        else if (i === 1) tempRanks[h.id] = 2;
                        else if (i === 2) tempRanks[h.id] = 3;
                    });

                    const batch = writeBatch(db);
                    const scoreUpdates = {};
                    const likeUpdates = {};
                    this.players.forEach(p => { scoreUpdates[p.uid] = 0; likeUpdates[p.uid] = 0; });

                    for (const h of this.currentHaikus) {
                        const rank = tempRanks[h.id] || 0;
                        let rankScore = 0;
                        if (rank === 1) rankScore = 100;
                        else if (rank === 2) rankScore = 60;
                        else if (rank === 3) rankScore = 20;

                        const likeCount = h.likes ? h.likes.length : 0;
                        const likeScore = likeCount * (this.settings.likePoints || 10);
                        const bonusScore = rankScore + likeScore;
                        const totalScore = (h.cardScore || 0) + bonusScore;

                        const hRef = doc(db, "rooms", this.roomId, "haikus", h.id);
                        batch.update(hRef, { rank, bonusScore, totalScore });

                        if (scoreUpdates[h.userId] !== undefined) {
                            scoreUpdates[h.userId] += totalScore;
                            likeUpdates[h.userId] += likeCount;
                        }
                    }

                    const newPlayers = this.players.map(p => {
                        return {
                            ...p,
                            score: p.score + (scoreUpdates[p.uid] || 0),
                            totalLikes: (p.totalLikes || 0) + (likeUpdates[p.uid] || 0)
                        };
                    });

                    batch.update(roomRef, { players: newPlayers, status: 'RESULT' });
                    await batch.commit();
                },

                async old_addNPC() {
                    if (!this.roomId) return;
                    const npcId = 'npc-' + Math.random().toString(36).substr(2, 5);
                    const npcNames = ['一茶', '蕪村', '子規', '虚子', '晶子', '啄木', '万葉'];
                    const name = 'NPC ' + npcNames[Math.floor(Math.random() * npcNames.length)];

                    const newPlayer = {
                        uid: npcId,
                        name: name,
                        score: 0,
                        totalLikes: 0,
                        winCount: 0,
                        hand: generateHand()
                    };

                    await updateDoc(doc(db, "rooms", this.roomId), {
                        players: arrayUnion(newPlayer)
                    });
                },

                async npcSubmitAll() {
                    const batch = writeBatch(db);
                    const haikusRef = collection(db, "rooms", this.roomId, "haikus");

                    // 未提出のNPCを探す
                    const unsubmittedNPCs = this.players.filter(p => {
                        return p.uid.startsWith('npc-') &&
                            p.uid !== this.masterUid &&
                            !this.currentHaikus.find(h => h.userId === p.uid);
                    });

                    if (unsubmittedNPCs.length === 0) {
                        alert('提出可能なNPCはいません');
                        return;
                    }

                    unsubmittedNPCs.forEach(p => {
                        // 手札からランダムに選ぶ
                        const top = p.hand.fives[Math.floor(Math.random() * p.hand.fives.length)];
                        const middle = p.hand.sevens[Math.floor(Math.random() * p.hand.sevens.length)];
                        // bottomはtopと被らないように
                        let bottomCands = p.hand.fives.filter(c => c.id !== top.id);
                        if (bottomCands.length === 0) bottomCands = [top];
                        const bottom = bottomCands[Math.floor(Math.random() * bottomCands.length)];

                        const cardScore = top.score + middle.score + bottom.score;

                        const newDocRef = doc(haikusRef);
                        batch.set(newDocRef, {
                            userId: p.uid,
                            top, middle, bottom,
                            gameCount: this.gameCount,
                            round: this.roundCount,
                            rank: 0, likes: [], cardScore, bonusScore: 0, totalScore: 0,
                            randomSortKey: Math.random()
                        });
                    });

                    await batch.commit();
                },

                async addToHallOfFame() {
                    if (!this.topLikedHaikus || this.topLikedHaikus.length === 0) {
                        alert("MVP俳句がないため登録できません");
                        return;
                    }
                    if (!confirm("現在の結果を殿堂入りに登録しますか？")) return;

                    try {
                        await addDoc(collection(db, "hallOfFame"), {
                            createdAt: Date.now(),
                            roomId: this.roomId,
                            players: this.sortedPlayers, // 最終順位（favoriteHaikuId含む）
                            mvpHaikus: this.topLikedHaikus,
                            favoriteHaikusData: this.getFavoritedHaikuObjects(), // お気に入り俳句の実体
                            gameCount: this.gameCount
                        });
                        alert("殿堂入りに登録しました！");
                    } catch (e) {
                        console.error("Hall of fame error:", e);
                        alert("登録に失敗しました: " + e.message);
                    }
                },

                // --- お気に入り機能 ---
                getMyFavoriteHaikuId() {
                    const p = this.players.find(x => x.uid === this.myUid);
                    return p ? p.favoriteHaikuId : null;
                },

                async toggleFavorite(haiku) {
                    const myIdx = this.players.findIndex(p => p.uid === this.myUid);
                    if (myIdx === -1) return;

                    const updatedPlayers = [...this.players];
                    if (updatedPlayers[myIdx].favoriteHaikuId === haiku.id) {
                        updatedPlayers[myIdx].favoriteHaikuId = null;
                    } else {
                        updatedPlayers[myIdx].favoriteHaikuId = haiku.id;
                    }

                    await updateDoc(doc(db, "rooms", this.roomId), { players: updatedPlayers });
                },

                getHaikuText(haikuId) {
                    const h = this.allGameHaikus.find(x => x.id === haikuId);
                    if (!h) return '不明な俳句';
                    return `${h.top.text} ${h.middle.text} ${h.bottom.text}`;
                },

                getFavoritedHaikusSummary() {
                    const map = new Map();
                    this.players.forEach(p => {
                        if (!p.favoriteHaikuId) return;
                        const h = this.allGameHaikus.find(x => x.id === p.favoriteHaikuId);
                        if (!h) return;
                        if (!map.has(h.id)) {
                            map.set(h.id, { haiku: h, fanNames: [] });
                        }
                        map.get(h.id).fanNames.push(p.name);
                    });
                    return Array.from(map.values());
                },

                getFavoritedHaikuObjects() {
                    const ids = new Set();
                    this.players.forEach(p => {
                        if (p.favoriteHaikuId) ids.add(p.favoriteHaikuId);
                    });
                    const list = [];
                    ids.forEach(id => {
                        const h = this.allGameHaikus.find(x => x.id === id);
                        if (h) list.push(h);
                    });
                    return list;
                },

                // --- 殿堂入りヘルパー ---
                toggleHallOfFameDetail(id) {
                    if (this.expandedRecordId === id) this.expandedRecordId = null;
                    else this.expandedRecordId = id;
                },

                getPlayerNameFromRecord(record, uid) {
                    const p = record.players.find(x => x.uid === uid);
                    return p ? p.name : '不明';
                },

                getHaikuTextFromRecord(record, haikuId) {
                    let h = record.mvpHaikus ? record.mvpHaikus.find(x => x.id === haikuId) : null;
                    if (!h && record.favoriteHaikusData) {
                        h = record.favoriteHaikusData.find(x => x.id === haikuId);
                    }
                    if (!h) return '記録なし';
                    return `${h.top.text} ${h.middle.text} ${h.bottom.text}`;
                },

                getFavoritedHaikusFromRecord(record) {
                    if (!record.players) return [];
                    const map = new Map();
                    record.players.forEach(p => {
                        if (!p.favoriteHaikuId) return;
                        let h = record.mvpHaikus ? record.mvpHaikus.find(x => x.id === p.favoriteHaikuId) : null;
                        if (!h && record.favoriteHaikusData) {
                            h = record.favoriteHaikusData.find(x => x.id === p.favoriteHaikuId);
                        }
                        if (!h) return;
                        if (!map.has(h.id)) {
                            map.set(h.id, { haiku: h, fanNames: [] });
                        }
                        map.get(h.id).fanNames.push(p.name);
                    });
                    return Array.from(map.values());
                },

                async openHallOfFame() {
                    this.isLoading = true;
                    try {
                        const q = window.query || ((ref, opts) => ref); // query関数がimportされていない場合の対策が必要だが、今回はCDNから全部取ってるはず。
                        // firebase-firestore.jsのimportにquery, orderBy, limitを追加する必要があるかも。
                        // 先ほどのimport文を確認すると、query, orderBy, limit が足りない可能性がある。
                        // ここでは、一旦全件取得してJSでソートする（件数が少なければ問題ない）

                        const snap = await getDocs(collection(db, "hallOfFame"));
                        const list = snap.docs.map(d => ({ id: d.id, ...d.data() }));

                        // 日付降順
                        list.sort((a, b) => b.createdAt - a.createdAt);

                        this.hallOfFameList = list;
                        this.viewState = 'HALL_OF_FAME';
                    } catch (e) {
                        console.error(e);
                        alert("読み込み失敗: " + e.message);
                    } finally {
                        this.isLoading = false;
                    }
                },

                closeHallOfFame() {
                    this.viewState = 'LOBBY';
                    this.hallOfFameList = [];
                },

                async resetHallOfFame() {
                    const password = prompt("殿堂入りをリセットするためのパスワードを入力してください");
                    if (password !== "1111") {
                        alert("パスワードが違います");
                        return;
                    }

                    if (!confirm("本当に全ての殿堂入りデータを削除しますか？\nこの操作は取り消せません。")) return;

                    this.isLoading = true;
                    try {
                        const batch = writeBatch(db);
                        this.hallOfFameList.forEach(record => {
                            const ref = doc(db, "hallOfFame", record.id);
                            batch.delete(ref);
                        });
                        await batch.commit();

                        this.hallOfFameList = [];
                        alert("殿堂入りデータをリセットしました");
                    } catch (e) {
                        console.error(e);
                        alert("リセット失敗: " + e.message);
                    } finally {
                        this.isLoading = false;
                    }
                },

                formatDate(ts) {
                    if (!ts) return '-';
                    const d = new Date(ts);
                    return d.toLocaleString('ja-JP', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                },

                // npcLikeAllなどの既存メソッドの後に続く
                async npcLikeAll() {
                    // いいねしていないNPCを探す
                    // 親ではないNPC
                    const voterNPCs = this.players.filter(p => {
                        return p.uid.startsWith('npc-') && p.uid !== this.masterUid;
                    });

                    // 自分がいいね済みの判定が難しいので（likes配列を見る必要がある）、
                    // ここではシンプルに「まだ誰にもいいねしていないNPC」にランダムな句へいいねさせる
                    // ※厳密には「自分の句にはいいねできない」ルールも適用すべき

                    const updates = [];

                    for (const npc of voterNPCs) {
                        // npcが既にいいねしているかチェック
                        const alreadyVoted = this.currentHaikus.some(h => h.likes && h.likes.includes(npc.uid));
                        if (alreadyVoted) continue;

                        // いいね対象候補（自分の句以外）
                        const candidates = this.currentHaikus.filter(h => h.userId !== npc.uid);
                        if (candidates.length === 0) continue;

                        const target = candidates[Math.floor(Math.random() * candidates.length)];

                        // 更新用Mapに追加
                        // 同じ句に複数のNPCが入れる可能性があるので、transactionか、あるいは一つずつ処理する
                        // ここでは簡単のため一つずつupdateDocする
                        const haikuRef = doc(db, "rooms", this.roomId, "haikus", target.id);
                        await updateDoc(haikuRef, { likes: arrayUnion(npc.uid) });
                    }
                }
            }
        }).mount('#app');
    </script>
</body>

</html>