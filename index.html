<!DOCTYPE html>
<html lang="ja">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ€§ç™–å¥ä¼šãƒ­ãƒ¯ã‚¤ãƒ¤ãƒ« - Online</title>
    <!-- Vue.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/vue/3.4.19/vue.global.prod.min.js"></script>
    <!-- ãƒ•ã‚©ãƒ³ãƒˆ -->
    <link href="https://fonts.googleapis.com/css2?family=Shippori+Mincho:wght@400;700&display=swap" rel="stylesheet">

    <style>
        /* --- ãƒ‡ã‚¶ã‚¤ãƒ³å®šç¾© --- */
        :root {
            --bg-color: #fcfaf2;
            --text-color: #3e3a39;
            --accent-color: #b93a32;
            --oni-color: #800080;
            --sub-color: #2a3a55;
            --gold-color: #c5a059;
            --free-color: #2e8b57;
        }

        body {
            font-family: 'Shippori Mincho', serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            background-image: radial-gradient(#e6e2d3 1px, transparent 1px);
            background-size: 20px 20px;
            padding-bottom: 50px;
        }

        [v-cloak] {
            display: none;
        }

        .app-container {
            max-width: 600px;
            margin: 0 auto;
            min-height: 100vh;
            padding: 10px;
            box-sizing: border-box;
        }

        h1,
        h2,
        h3 {
            text-align: center;
            margin-bottom: 0.5em;
        }

        .logo {
            font-size: 1.8rem;
            border-bottom: 3px double var(--accent-color);
            display: inline-block;
            margin-bottom: 15px;
            margin-top: 10px;
        }

        .card-box {
            background: #fff;
            border: 1px solid #dcdcdc;
            box-shadow: 2px 2px 0px rgba(0, 0, 0, 0.1);
            padding: 15px;
            margin-bottom: 15px;
            border-radius: 4px;
        }

        /* é †ä½è¡¨ã‚¨ãƒªã‚¢ */
        .scoreboard {
            font-size: 0.85rem;
            background: #fdfdfd;
            border: 1px solid #eee;
            padding: 10px;
            margin-bottom: 15px;
        }

        .score-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px dotted #ccc;
            padding: 6px 0;
        }

        .master-badge {
            font-size: 0.7rem;
            padding: 1px 4px;
            border-radius: 3px;
            margin-left: 5px;
        }

        .master-done {
            background: #ddd;
            color: #555;
        }

        .master-yet {
            background: var(--accent-color);
            color: white;
        }

        .heart-count {
            color: #e91e63;
            font-weight: bold;
            margin-right: 8px;
            font-size: 0.9rem;
        }

        .btn {
            background-color: var(--sub-color);
            color: #fff;
            border: none;
            padding: 10px;
            font-family: 'Shippori Mincho', serif;
            font-size: 1rem;
            cursor: pointer;
            border-radius: 4px;
            width: 100%;
            transition: transform 0.1s;
        }

        .btn:active {
            transform: translateY(2px);
        }

        .btn:disabled {
            background-color: #ccc;
            cursor: not-allowed;
        }

        .btn-primary {
            background-color: var(--accent-color);
            font-weight: bold;
        }

        .btn-danger {
            background-color: #d9534f;
            font-size: 0.9rem;
            padding: 8px;
            border-radius: 4px;
            border: none;
            color: white;
            cursor: pointer;
        }

        .btn-add {
            background-color: var(--free-color);
            width: auto;
            padding: 5px 15px;
            font-size: 0.9rem;
        }

        /* ä¿³å¥ä½œæˆã‚¨ãƒªã‚¢ */
        .haiku-preview {
            display: flex;
            flex-direction: column;
            gap: 8px;
            margin-bottom: 15px;
            background: #eee;
            padding: 15px;
            border-radius: 8px;
            align-items: center;
        }

        .haiku-slot {
            width: 100%;
            padding: 10px;
            background: #fff;
            border: 2px dashed #aaa;
            text-align: center;
            font-size: 1.1rem;
            cursor: pointer;
            border-radius: 4px;
            min-height: 1.5em;
        }

        .haiku-slot.filled {
            border: 2px solid var(--sub-color);
            background: #f0f8ff;
            font-weight: bold;
        }

        .haiku-slot.filled.oni {
            border: 2px solid var(--oni-color);
            background: #f3e6f3;
            color: var(--oni-color);
        }

        .haiku-slot.filled.free {
            border: 2px solid var(--free-color);
            background: #f0fff0;
            color: #006400;
        }

        /* è‡ªç”±è¨˜å…¥ã‚¨ãƒªã‚¢ */
        .free-input-area {
            background: #f9f9f9;
            padding: 10px;
            border: 1px dashed #ccc;
            margin-bottom: 15px;
            border-radius: 4px;
        }

        .radio-group {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
            font-size: 0.85rem;
        }

        .input-row {
            display: flex;
            gap: 5px;
        }

        /* æ‰‹æœ­ã‚¨ãƒªã‚¢ */
        .hand-section {
            margin-top: 10px;
        }

        .hand-label {
            font-size: 0.9rem;
            font-weight: bold;
            color: #666;
            margin-bottom: 5px;
        }

        .card-list {
            display: flex;
            flex-wrap: wrap;
            gap: 6px;
            justify-content: flex-start;
        }

        .word-card {
            padding: 8px 10px;
            border: 1px solid #ccc;
            border-radius: 4px;
            background: #fff;
            cursor: pointer;
            font-size: 0.9rem;
            position: relative;
            text-align: center;
            flex-grow: 0;
            flex-shrink: 0;
        }

        .word-card.oni {
            border-color: var(--oni-color);
            color: var(--oni-color);
            background: #fffafa;
            font-weight: bold;
        }

        .word-card.free {
            border-color: var(--free-color);
            color: #006400;
        }

        .word-card.selected {
            background: #ccc;
            color: #fff;
            pointer-events: none;
        }

        .point-badge {
            position: absolute;
            top: -6px;
            right: -6px;
            background: var(--sub-color);
            color: #fff;
            font-size: 0.65rem;
            padding: 2px 4px;
            border-radius: 4px;
            z-index: 1;
        }

        .word-card.oni .point-badge {
            background: var(--oni-color);
        }

        .word-card.free .point-badge {
            background: var(--free-color);
        }

        /* çŸ­å†Šãƒªã‚¹ãƒˆ */
        .tanzaku {
            background: #fff;
            padding: 10px 15px;
            border-left: 5px solid var(--sub-color);
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.05);
            margin-bottom: 10px;
        }

        .rank-badge {
            padding: 2px 8px;
            color: white;
            font-size: 0.8rem;
            border-radius: 4px;
            margin-right: 5px;
        }

        .error-msg {
            color: var(--accent-color);
            font-weight: bold;
            margin-bottom: 10px;
            display: block;
        }

        .win-badge {
            display: inline-flex;
            align-items: center;
            background: #fff8dc;
            border: 1px solid #ffd700;
            border-radius: 20px;
            padding: 2px 8px;
            margin-left: 5px;
            font-size: 0.85rem;
            color: #d2691e;
            font-weight: bold;
        }

        .win-icon {
            width: 20px;
            height: 20px;
            margin-right: 4px;
            vertical-align: middle;
        }

        /* --- ãƒ‡ãƒãƒƒã‚°ç”¨ --- */
        /* --- ä¿³å¥æ¼”å‡ºã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ --- */
        .special-overlay {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            background: rgba(0, 0, 0, 0.9);
            z-index: 10000;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
        }

        .special-bg {
            position: absolute;
            width: 200%;
            height: 200%;
            background: radial-gradient(circle, gold 0%, transparent 10%);
            background-size: 20px 20px;
            opacity: 0.2;
            animation: stars 10s linear infinite;
        }

        .special-content {
            position: relative;
            text-align: center;
            color: #fff;
            font-family: 'Shippori Mincho', serif;
        }

        .special-text {
            font-size: 3rem;
            font-weight: bold;
            text-shadow: 0 0 10px gold, 0 0 20px orangered;
            /* writing-mode: vertical-rl; */
            /* text-orientation: upright; */
            height: auto;
            display: flex;
            flex-direction: column;
            justify-content: center;
            gap: 1.5rem;
            margin: 0 auto;
            padding: 50px 0;
        }

        .phrase {
            opacity: 0;
            transform: scale(3);
            animation: stamp-in 0.5s forwards;
        }

        .phrase.top {
            animation-delay: 0.5s;
        }

        .phrase.middle {
            animation-delay: 1.5s;
        }

        .phrase.bottom {
            animation-delay: 2.5s;
        }

        .special-footer {
            position: absolute;
            bottom: -50px;
            left: 0;
            right: 0;
            font-size: 1.5rem;
            color: gold;
            opacity: 0;
            animation: fade-up 1s forwards 3.5s;
        }

        @keyframes stamp-in {
            0% {
                opacity: 0;
                transform: scale(3);
            }

            50% {
                opacity: 1;
                transform: scale(0.8);
            }

            100% {
                opacity: 1;
                transform: scale(1);
            }
        }

        @keyframes fade-up {
            from {
                opacity: 0;
                transform: translateY(20px);
            }

            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes stars {
            from {
                transform: translateY(0);
            }

            to {
                transform: translateY(-50%);
            }
        }

        .debug-panel {
            position: fixed;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.9);
            color: #fff;
            padding: 10px;
            border-radius: 8px;
            z-index: 9999;
            font-size: 0.8rem;
            width: 320px;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        .debug-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin-bottom: 10px;
            border-bottom: 1px solid #555;
            padding-bottom: 5px;
        }

        .debug-tab {
            background: #333;
            color: #ccc;
            padding: 4px 8px;
            border-radius: 4px 4px 0 0;
            cursor: pointer;
            font-size: 0.75rem;
            border: 1px solid #444;
        }

        .debug-tab.active {
            background: #e91e63;
            color: white;
            font-weight: bold;
            border-color: #e91e63;
        }

        .debug-btn {
            background: #555;
            color: white;
            border: 1px solid #777;
            padding: 4px 8px;
            margin: 2px;
            cursor: pointer;
            width: 100%;
            text-align: left;
        }

        .debug-btn:hover {
            background: #777;
        }
    </style>
</head>

<body>

    <div id="app" class="app-container" v-cloak>

        <div style="text-align: center;">
            <div class="logo">æ€§ç™–å¥ä¼šãƒ­ãƒ¯ã‚¤ãƒ¤ãƒ«</div>
        </div>

        <!-- 1. ãƒ­ãƒ“ãƒ¼ç”»é¢ -->
        <div v-if="viewState === 'LOBBY'" class="card-box" style="text-align:center;">
            <h2>å…¥å®¤</h2>
            <span v-if="errorMessage" class="error-msg">{{ errorMessage }}</span>

            <label>ãŠåå‰</label>
            <input type="text" v-model="myPlayerName" placeholder="ä¾‹ï¼šæ¾å°¾èŠ­è•‰"
                style="width:100%; padding:10px; margin-bottom:15px; box-sizing:border-box;">

            <label>éƒ¨å±‹ç•ªå·ï¼ˆ4æ¡ï¼‰</label>
            <input type="text" v-model="roomId" maxlength="4" placeholder="1234"
                style="width:100%; padding:10px; margin-bottom:15px; box-sizing:border-box;">

            <button class="btn btn-primary" @click="enterRoom" :disabled="!roomId || !myPlayerName || isLoading">
                {{ isLoading ? 'é€šä¿¡ä¸­...' : 'éƒ¨å±‹ã«å…¥ã‚‹ / ä½œã‚‹' }}
            </button>
            <div style="margin-top:15px; text-align:center;">
                <label style="display:inline-flex; align-items:center; cursor:pointer; color:#555; font-size:0.85rem;">
                    <input type="checkbox" v-model="isTestMode" style="margin-right:6px;">
                    ğŸ› ï¸ ãƒ†ã‚¹ãƒˆãƒ¢ãƒ¼ãƒ‰ (NPCæ©Ÿèƒ½ãªã©)
                </label>
            </div>

            <!-- ãƒ«ãƒ¼ãƒ ãƒªã‚»ãƒƒãƒˆãƒœã‚¿ãƒ³ -->
            <div style="margin-top:20px; padding-top:15px; border-top:1px dashed #ccc;">
                <p style="font-size:0.8rem; color:#666; margin-bottom:8px;">å‰å›ã®ãƒ«ãƒ¼ãƒ æƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆã—ãŸã„å ´åˆ</p>
                <button class="btn" style="background:#888; font-size:0.85rem;" @click="resetRoom"
                    :disabled="!roomId || isLoading">
                    ğŸ—‘ï¸ ãƒ«ãƒ¼ãƒ æƒ…å ±ã‚’ãƒªã‚»ãƒƒãƒˆ
                </button>
            </div>

            <div style="margin-top:15px;">
                <button class="btn" style="background:var(--oni-color); font-size:1rem;" @click="openHallOfFame">
                    ğŸ† æ®¿å ‚å…¥ã‚Šã‚’è¦‹ã‚‹
                </button>
            </div>
        </div>

        <!-- 2. ãƒ­ãƒ“ãƒ¼ï¼ˆå¾…æ©Ÿãƒ»è¨­å®šï¼‰ç”»é¢ -->
        <div v-else-if="viewState === 'WAITING'" class="card-box">
            <h2>ãƒ­ãƒ“ãƒ¼ / è¨­å®š</h2>
            <div style="text-align:center; margin-bottom:15px;">
                <p>ç¾åœ¨ <strong>{{ players.length }}</strong> åãŒå¾…æ©Ÿä¸­</p>
                <div
                    style="max-height: 150px; overflow-y: auto; text-align: left; background: #fff; border: 1px solid #ddd; padding: 10px; border-radius: 4px;">
                    <div v-for="p in players" :key="p.uid"
                        style="padding: 4px 0; border-bottom: 1px dotted #eee; display:flex; justify-content:space-between;">
                        <span>
                            <span v-if="p.uid === masterUid">ğŸ‘‘</span>
                            <span v-else>ğŸ‘¤</span>
                            {{ p.name }}
                            <span v-if="p.winCount && p.winCount > 0" class="win-badge"
                                style="font-size:0.8rem; margin-left:4px;">
                                <img src="./haiku_badge.png" class="win-icon" style="width:16px; height:16px;" alt="ğŸ†">
                                {{ p.winCount }}
                            </span>
                        </span>
                        <span v-if="p.uid === myUid" style="font-size:0.8rem; color:#888;">(ã‚ãªãŸ)</span>
                    </div>
                </div>
            </div>

            <!-- è¨­å®šã‚¨ãƒªã‚¢ (è¦ªã®ã¿ç·¨é›†å¯) -->
            <div style="background:#f9f9f9; padding:15px; border-radius:8px; margin-bottom:20px;">
                <h3 style="margin-top:0;">ãƒ«ãƒ¼ãƒ«è¨­å®š</h3>

                <div style="margin-bottom:10px;">
                    <label style="display:block; font-weight:bold;">â³ åˆ¶é™æ™‚é–“ (åˆ†)</label>
                    <div v-if="isMeMaster">
                        <input type="range" v-model.number="tempSettings.timeLimitMin" min="1" max="10" step="1"
                            style="width:100%;" @change="saveSettings">
                        <div style="text-align:right;">{{ tempSettings.timeLimitMin }} åˆ†</div>
                    </div>
                    <div v-else>
                        {{ settings.timeLimit / 60 }} åˆ†
                    </div>
                </div>

                <div style="margin-bottom:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label style="font-weight:bold;">ğŸ­ è¦ªã‚’è¡¨ç¤ºã™ã‚‹</label>
                        <div v-if="isMeMaster">
                            <input type="checkbox" v-model="tempSettings.showMaster" style="transform:scale(1.5);"
                                @change="saveSettings">
                        </div>
                        <div v-else>
                            {{ settings.showMaster ? 'ON' : 'OFF' }}
                        </div>
                    </div>
                    <p style="font-size:0.8rem; color:#666; margin-top:2px;">
                        {{ tempSettings.showMaster ? 'èª°ãŒè¦ªã‹è¡¨ç¤ºã•ã‚Œã¾ã™' : 'èª°ãŒè¦ªã‹ã‚ã‹ã‚Šã¾ã›ã‚“ï¼ˆãƒ‰ã‚­ãƒ‰ã‚­ï¼ï¼‰' }}
                    </p>
                </div>

                <div style="margin-bottom:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label style="font-weight:bold;">ğŸ“Š ç‚¹æ•°ãƒ»é †ä½ã‚’è¡¨ç¤º</label>
                        <div v-if="isMeMaster">
                            <input type="checkbox" v-model="tempSettings.showScore" style="transform:scale(1.5);"
                                @change="saveSettings">
                        </div>
                        <div v-else>
                            {{ settings.showScore ? 'ON' : 'OFF' }}
                        </div>
                    </div>
                    <p style="font-size:0.8rem; color:#666; margin-top:2px;">
                        OFFã«ã™ã‚‹ã¨å‹ã¡è² ã‘ã‚’æ°—ã«ã›ãšæ¥½ã—ã‚ã¾ã™
                    </p>
                </div>

                <div style="margin-bottom:10px;">
                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <label style="font-weight:bold;">ğŸ‰ å…¨å“¡å‚åŠ ãƒ¢ãƒ¼ãƒ‰</label>
                        <div v-if="isMeMaster">
                            <input type="checkbox" v-model="tempSettings.everyonePlays" style="transform:scale(1.5);"
                                @change="saveSettings">
                        </div>
                        <div v-else>
                            {{ settings.everyonePlays ? 'ON' : 'OFF' }}
                        </div>
                    </div>
                    <p style="font-size:0.8rem; color:#666; margin-top:2px;">
                        è¦ªã‚‚ä¿³å¥ã‚’è© ã¿ã€ã„ã„ã­ã ã‘ã§ç«¶ã„ã¾ã™ï¼ˆé †ä½ãªã—ï¼‰
                    </p>
                </div>

                <div style="margin-bottom:10px;">
                    <label style="display:block; font-weight:bold;">ğŸƒ é…å¸ƒæšæ•° (5æ–‡å­—)</label>
                    <div v-if="isMeMaster">
                        <input type="range" v-model.number="tempSettings.handSizeFive" min="1" max="10" step="1"
                            style="width:100%;" @change="saveSettings">
                        <div style="text-align:right;">{{ tempSettings.handSizeFive || 10 }} æš</div>
                    </div>
                    <div v-else>
                        {{ settings.handSizeFive || 10 }} æš
                    </div>
                </div>

                <div style="margin-bottom:10px;">
                    <label style="display:block; font-weight:bold;">ğŸƒ é…å¸ƒæšæ•° (7æ–‡å­—)</label>
                    <div v-if="isMeMaster">
                        <input type="range" v-model.number="tempSettings.handSizeSeven" min="1" max="10" step="1"
                            style="width:100%;" @change="saveSettings">
                        <div style="text-align:right;">{{ tempSettings.handSizeSeven || 5 }} æš</div>
                    </div>
                    <div v-else>
                        {{ settings.handSizeSeven || 5 }} æš
                    </div>
                </div>

                <div style="margin-bottom:10px;">
                    <label style="display:block; font-weight:bold;">â¤ï¸ ã„ã„ã­ã®ç‚¹æ•°</label>
                    <div v-if="isMeMaster">
                        <input type="number" v-model.number="tempSettings.likePoints" min="0" max="100"
                            style="padding:5px; width:80px;" @change="saveSettings"> ç‚¹
                    </div>
                    <div v-else>
                        {{ settings.likePoints }} ç‚¹
                    </div>
                </div>
            </div>

            <div v-if="isMeMaster" style="text-align:center;">
                <button class="btn btn-primary" @click="startGame">ã‚²ãƒ¼ãƒ é–‹å§‹ï¼</button>
            </div>
            <div v-else style="text-align:center; color:#666;">
                è¦ªãŒè¨­å®šä¸­ã§ã™ã€‚é–‹å§‹ã‚’ãŠå¾…ã¡ãã ã•ã„...
            </div>

            <div style="margin-top:20px; text-align:center;">
                <button class="btn btn-danger" style="width:auto; padding:5px 10px; font-size:0.8rem;"
                    @click="leaveRoom">é€€å‡º</button>
            </div>
        </div>

        <!-- 2. ã‚²ãƒ¼ãƒ ç”»é¢ -->
        <div v-else-if="viewState === 'GAME'">

            <!-- ãƒ˜ãƒƒãƒ€ãƒ¼æƒ…å ± -->
            <div
                style="display:flex; justify-content:space-between; align-items:center; margin-bottom:5px; font-size:0.9rem; font-weight:bold;">
                <span>ç¬¬ {{ roundCount }} / {{ players.length }} å¥</span>
                <span>
                    è¦ªï¼š{{ settings.showMaster ? getMasterName() : '???' }}
                    <span v-if="gamePhase === 'WRITING' && timeLeft > 0"
                        style="margin-left:10px; color:var(--accent-color);">
                        æ®‹ã‚Š {{ Math.floor(timeLeft / 60) }}:{{ ('0' + (timeLeft % 60)).slice(-2) }}
                    </span>
                    <span v-else-if="gamePhase === 'WRITING'" style="margin-left:10px; color:red;">çµ‚äº†ï¼</span>
                </span>
                <button class="btn btn-danger" style="width:auto; padding:5px 10px; font-size:0.75rem;"
                    @click="leaveRoom">é€€å‡º</button>
            </div>

            <!-- é †ä½è¡¨ -->
            <div class="card-box scoreboard">
                <div style="font-weight:bold; margin-bottom:5px; text-align:center;">ç¾åœ¨ã®é †ä½è¡¨</div>
                <div v-for="(p, index) in sortedPlayers" :key="p.uid" class="score-row">
                    <div style="display:flex; align-items:center;">
                        <span style="display:inline-block; width:20px; text-align:center; font-weight:bold;">
                            {{ settings.showScore ? (index + 1) : '-' }}
                        </span>
                        <span>{{ p.name }}</span>
                        <span v-if="p.winCount && p.winCount > 0" class="win-badge"
                            style="font-size:0.8rem; margin-left:4px;">
                            <img src="./haiku_badge.png" class="win-icon" style="width:16px; height:16px;" alt="ğŸ†">
                            {{
                            p.winCount }}
                        </span>
                        <!-- è¦ªè¡¨ç¤ºè¨­å®šãŒOFFã®ã¨ãã¯ã€Œè¦ªæ¸ˆã€ãƒãƒƒã‚¸ã‚‚éš ã™ï¼ˆèª°ãŒè¦ªã‹ã‚ã‹ã‚‰ãªã„ã‚ˆã†ã«ï¼‰ -->
                        <span v-if="settings.showMaster" class="master-badge"
                            :class="hasBeenMaster(p.uid) ? 'master-done' : 'master-yet'">
                            {{ hasBeenMaster(p.uid) ? 'è¦ªæ¸ˆ' : 'è¦ªæœª' }}
                        </span>
                    </div>
                    <div>
                        <span class="heart-count">â¤ï¸ {{ p.totalLikes || 0 }}</span>
                        <b v-if="settings.showScore">{{ p.score }} pt</b>
                    </div>
                </div>
            </div>

            <!-- A. è© å”±ã‚¿ã‚¤ãƒ  -->
            <div v-if="gamePhase === 'WRITING'">
                <div style="text-align:center; margin-bottom:10px;">
                    <p v-if="isMeMaster && !settings.everyonePlays">ã‚ãªãŸã¯ã€Œè¦ªã€ã§ã™ã€‚çš†ã®æå‡ºã‚’å¾…ã¡ã¾ã—ã‚‡ã†ã€‚</p>
                    <p v-else>æ‰‹æœ­ã‹ã‚‰æœ€å¼·ã®å¥ã‚’è© ã‚“ã§ãã ã•ã„ã€‚</p>
                    <!-- å…¨å“¡ã«æå‡ºçŠ¶æ³ã‚’è¡¨ç¤º -->
                    <div style="background:#f0f0f0; padding:8px; border-radius:4px; margin-top:5px;">
                        ğŸ“ æå‡ºçŠ¶æ³: <strong>{{ submittedCount }} / {{ settings.everyonePlays ? players.length :
                            players.length - 1 }}</strong> äºº
                    </div>
                </div>

                <!-- è¦ªã®ç”»é¢ (é€šå¸¸ãƒ¢ãƒ¼ãƒ‰) -->
                <div v-if="isMeMaster && !settings.everyonePlays" class="card-box" style="text-align:center;">
                    <button class="btn btn-primary" @click="forceAllSubmit"
                        :disabled="submittedCount >= players.length - 1">
                        æœªæå‡ºè€…ã‚’å¼·åˆ¶æå‡ºã•ã›ã¦æ¬¡ã¸
                    </button>
                    <p style="font-size:0.8rem; color:#666; margin-top:5px;">â€»å…¨å“¡å‡ºã™ã¨è‡ªå‹•ã§é€²ã¿ã¾ã™</p>
                </div>

                <!-- å­ã®ç”»é¢ï¼ˆã¾ãŸã¯å…¨å“¡å‚åŠ ãƒ¢ãƒ¼ãƒ‰ã®å…¨å“¡ï¼‰ -->
                <div v-else>
                    <!-- è¦ªç”¨ã®å¼·åˆ¶é€²è¡Œãƒœã‚¿ãƒ³ï¼ˆå…¨å“¡å‚åŠ ãƒ¢ãƒ¼ãƒ‰æ™‚ï¼‰ -->
                    <div v-if="isMeMaster && settings.everyonePlays" class="card-box"
                        style="text-align:center; margin-bottom:15px; background:#fff3e0;">
                        <p style="font-size:0.9rem; font-weight:bold; color:#e65100; margin-bottom:5px;">
                            ã‚ãªãŸã¯è¦ªã§ã™ãŒã€ä»Šå›ã¯å‚åŠ è€…ã§ã™ï¼</p>
                        <button class="btn btn-secondary" @click="forceAllSubmit"
                            style="font-size:0.8rem; padding:4px 8px;" :disabled="submittedCount >= players.length">
                            å¼·åˆ¶çš„ã«æ¬¡ã¸é€²ã‚€
                        </button>
                    </div>
                    <!-- ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼ & ãƒªã‚»ãƒƒãƒˆ -->
                    <div class="haiku-preview">
                        <!-- ä¸Šäº” -->
                        <div class="haiku-slot" :class="getSlotClass(myDraft.top)" @click="removePart('top')">
                            {{ myDraft.top ? myDraft.top.text : 'ï¼ˆä¸Šäº”ï¼‰' }}
                        </div>
                        <!-- ä¸­ä¸ƒ -->
                        <div class="haiku-slot" :class="getSlotClass(myDraft.middle)" @click="removePart('middle')">
                            {{ myDraft.middle ? myDraft.middle.text : 'ï¼ˆä¸­ä¸ƒï¼‰' }}
                        </div>
                        <!-- ä¸‹äº” -->
                        <div class="haiku-slot" :class="getSlotClass(myDraft.bottom)" @click="removePart('bottom')">
                            {{ myDraft.bottom ? myDraft.bottom.text : 'ï¼ˆä¸‹äº”ï¼‰' }}
                        </div>

                        <div style="display:flex; justify-content:space-between; width:100%; align-items:center;">
                            <button class="btn btn-danger" @click="resetDraft" :disabled="hasSubmitted">
                                â†º ãƒªã‚»ãƒƒãƒˆ (è‡ªç”±è¨˜å…¥ã‚‚å‰Šé™¤)
                            </button>
                            <div style="font-size:0.9rem;">ã‚«ãƒ¼ãƒ‰ç‚¹: <b>{{ currentDraftScore }}</b></div>
                        </div>
                    </div>

                    <div v-if="!hasSubmitted">
                        <!-- è‡ªç”±è¨˜å…¥æ¬„ (1å›åˆ¶é™) -->
                        <div class="free-input-area">
                            <div style="font-size:0.8rem; font-weight:bold; margin-bottom:5px;">
                                ğŸ–Šï¸ è‡ªç”±è¨˜å…¥ (1æšã ã‘ä½œã‚Œã¾ã™)
                            </div>
                            <div v-if="!hasCreatedFreeCard">
                                <div class="radio-group">
                                    <label><input type="radio" v-model="freeInputType" :value="5"> 5æ–‡å­—(ä¸Š/ä¸‹)</label>
                                    <label><input type="radio" v-model="freeInputType" :value="7"> 7æ–‡å­—(ä¸­)</label>
                                </div>
                                <div class="input-row">
                                    <input type="text" v-model="freeInputText" placeholder="å¥½ããªè¨€è‘‰"
                                        style="flex-grow:1; padding:5px;">
                                    <button class="btn btn-add" @click="addFreeCard"
                                        :disabled="!freeInputText">è¿½åŠ </button>
                                </div>
                            </div>
                            <div v-else style="font-size:0.85rem; color:#2e8b57; text-align:center;">
                                â€» è‡ªç”±è¨˜å…¥ã‚«ãƒ¼ãƒ‰ä½œæˆæ¸ˆã¿
                            </div>
                        </div>

                        <!-- æ‰‹æœ­ãƒªã‚¹ãƒˆ -->
                        <div class="hand-section">
                            <div class="hand-label">ã€äº”æ–‡å­—ã€‘ã‚¿ãƒƒãƒ—ã§ä¸Šãƒ»ä¸‹ã«ã‚»ãƒƒãƒˆ</div>
                            <div class="card-list">
                                <div v-for="card in myHand.fives" :key="card.id" class="word-card"
                                    :class="getCardClass(card)" @click="selectFive(card)">
                                    {{ card.text }}
                                    <span class="point-badge">{{ card.score }}</span>
                                </div>
                            </div>
                        </div>

                        <div class="hand-section" style="margin-top:15px;">
                            <div class="hand-label">ã€ä¸ƒæ–‡å­—ã€‘ã‚¿ãƒƒãƒ—ã§ä¸­ã«ã‚»ãƒƒãƒˆ</div>
                            <div class="card-list">
                                <div v-for="card in myHand.sevens" :key="card.id" class="word-card"
                                    :class="getCardClass(card)" @click="selectSeven(card)">
                                    {{ card.text }}
                                    <span class="point-badge">{{ card.score }}</span>
                                </div>
                            </div>
                        </div>

                        <div style="margin-top:15px; text-align:center;">
                            <label
                                style="display:inline-flex; align-items:center; gap:5px; padding:8px; background:#fff8dc; border:1px solid #ffd700; border-radius:4px; font-weight:bold; cursor:pointer;">
                                <input type="checkbox" v-model="useSpecialEffect" :disabled="hasMySpecialEffectUsed">
                                <span>âœ¨ ä¿³å¥æ¼”å‡º (1è©¦åˆã«1å›ã®ã¿)</span>
                            </label>
                            <div v-if="hasMySpecialEffectUsed" style="font-size:0.75rem; color:red; margin-top:2px;">
                                â€» ã™ã§ã«æ¼”å‡ºã‚’ä½¿ç”¨æ¸ˆã¿ã§ã™
                            </div>
                        </div>

                        <button class="btn btn-primary" style="margin-top:10px;" @click="submitHaiku"
                            :disabled="!myDraft.top || !myDraft.middle || !myDraft.bottom">
                            è© ã‚€ï¼ˆæå‡ºï¼‰
                        </button>
                    </div>
                    <div v-else class="card-box" style="text-align:center;">
                        <p>æå‡ºå®Œäº†ï¼<br>è¦ªã®é¸è©•ã‚’å¾…ã£ã¦ã„ã¾ã™...</p>
                    </div>
                </div>
            </div>

            <!-- B. é¸è©•ã‚¿ã‚¤ãƒ  -->
            <div v-if="gamePhase === 'JUDGING'">
                <div class="card-box" style="text-align:center;">
                    <h3>é¸è©•ã‚¿ã‚¤ãƒ </h3>
                    <p v-if="isMeMaster && !settings.everyonePlays">ã‚°ãƒƒã¨ããŸé †ã«é †ä½ã‚’ã¤ã‘ã¦ãã ã•ã„</p>
                    <p v-else-if="settings.everyonePlays">å…¨å“¡ã§å¥½ããªå¥ã«ã„ã„ã­ã—ã¾ã—ã‚‡ã†ï¼</p>
                    <p v-else>è¦ªãŒé¸è€ƒä¸­ã§ã™â€¦</p>

                    <!-- å…¨ä½“ã®ã„ã„ã­çŠ¶æ³ -->
                    <div
                        style="background:#fff0f5; padding:5px; border-radius:4px; margin-top:5px; border:1px solid #ffb6c1; font-size:0.9rem;">
                        â¤ï¸ å…¨å“¡ã®ã„ã„ã­çŠ¶æ³: <strong>{{ likedCount }} / {{ likeTargetCount }}</strong> äºº
                    </div>

                    <!-- ã„ã„ã­é€²æ—è¡¨ç¤ºï¼ˆè¦ªä»¥å¤–ã®å‚åŠ è€…å‘ã‘ï¼‰ -->
                    <div v-if="!isMeMaster || settings.everyonePlays"
                        style="margin-top:10px; padding:10px; background:#fff0f5; border-radius:8px; border:1px solid #ffb6c1;">
                        <div v-if="hasLikedAny" style="color:#28a745; font-weight:bold;">
                            âœ… ã„ã„ã­æ¸ˆã¿ï¼ï¼ˆ1å¥é¸æŠå®Œäº†ï¼‰
                        </div>
                        <div v-else style="color:#dc3545; font-weight:bold;">
                            âš ï¸ ã„ã„ã­å¿…é ˆï¼1å¥ã ã‘â¤ï¸ã‚’æŠ¼ã—ã¦ãã ã•ã„
                        </div>
                    </div>
                </div>

                <div v-for="haiku in sortedHaikusForJudging" :key="haiku.id" class="tanzaku">
                    <div style="font-size:1.2rem; font-weight:bold; text-align:center; margin-bottom:5px;">
                        <span :style="{color: haiku.top.isOni ? 'purple' : 'inherit'}">{{ haiku.top.text }}</span>ã€€
                        <span :style="{color: haiku.middle.isOni ? 'purple' : 'inherit'}">{{ haiku.middle.text
                            }}</span>ã€€
                        <span :style="{color: haiku.bottom.isOni ? 'purple' : 'inherit'}">{{ haiku.bottom.text
                            }}</span>
                    </div>

                    <div style="display:flex; justify-content:space-between; font-size:0.8rem; color:#888;">
                        <span>ã‚«ãƒ¼ãƒ‰ç‚¹: {{ haiku.cardScore }}</span>
                        <span>è© ã¿äººçŸ¥ã‚‰ãš</span>
                    </div>

                    <div v-if="isMeMaster && !settings.everyonePlays"
                        style="margin-top:10px; border-top:1px dashed #ccc; padding-top:10px; text-align:center;">
                        <button v-for="r in [1,2,3]" :key="r" @click="setRank(haiku, r)"
                            :style="{background: (tempRankState[haiku.id] === r) ? 'var(--accent-color)' : '#ccc', color:'white', border:'none', padding:'5px 10px', margin:'0 3px', borderRadius:'4px'}">
                            {{ r }}ä½
                        </button>
                    </div>
                    <!-- ã„ã„ã­ãƒœã‚¿ãƒ³ï¼ˆè‡ªåˆ†ã®ä¿³å¥ä»¥å¤–ã€ã‹ã¤ã¾ã ã„ã„ã­ã—ã¦ã„ãªã„å ´åˆã®ã¿æŠ¼ã›ã‚‹ï¼‰ -->
                    <div v-else-if="haiku.userId !== myUid" style="text-align:right; margin-top:5px;">
                        <button @click="toggleLike(haiku)"
                            :disabled="hasLikedAny && !(haiku.likes && haiku.likes.includes(myUid))" :style="{
                                background: (haiku.likes && haiku.likes.includes(myUid)) ? '#e91e63' : 'none',
                                color: (haiku.likes && haiku.likes.includes(myUid)) ? 'white' : '#333',
                                border: '1px solid #ccc',
                                borderRadius: '15px',
                                padding: '5px 15px',
                                cursor: (hasLikedAny && !(haiku.likes && haiku.likes.includes(myUid))) ? 'not-allowed' : 'pointer',
                                opacity: (hasLikedAny && !(haiku.likes && haiku.likes.includes(myUid))) ? '0.5' : '1'
                            }">
                            {{ (haiku.likes && haiku.likes.includes(myUid)) ? 'â¤ï¸ ã„ã„ã­æ¸ˆï¼ˆå–æ¶ˆå¯ï¼‰' : 'ğŸ¤ ã„ã„ã­' }}
                        </button>
                    </div>
                </div>

                <!-- è¦ªã®å¼·åˆ¶é€²è¡Œãƒœã‚¿ãƒ³ -->
                <div v-if="isMeMaster" style="margin-top:20px;">
                    <button class="btn btn-primary" @click="finalizeJudging" :disabled="!canFinalize">
                        {{ settings.everyonePlays ? 'é›†è¨ˆã—ã¦çµæœç™ºè¡¨ã¸' : 'é †ä½æ±ºå®šãƒ»ç™ºè¡¨' }}
                    </button>
                    <button class="btn btn-danger" style="margin-top:10px;"
                        @click="forceFinalize">å¼·åˆ¶é€²è¡Œï¼ˆã„ã„ã­æœªå®Œäº†ã§ã‚‚é€²ã‚€ï¼‰</button>
                </div>
            </div>

            <!-- C. çµæœç™ºè¡¨ -->
            <div v-if="gamePhase === 'RESULT'">
                <div class="card-box" style="text-align:center; background:var(--sub-color); color:#fff;">
                    <h3>çµæœç™ºè¡¨</h3>
                </div>

                <div v-for="(haiku, index) in sortedHaikusForDisplay" :key="haiku.id" class="tanzaku"
                    v-show="visibleResultCount >= (sortedHaikusForDisplay.length - index)">

                    <div style="display:flex; justify-content:space-between; align-items:center;">
                        <div>
                            <span v-if="!settings.showScore" class="rank-badge"
                                style="background:#eee; color:#666;">ç™ºè¡¨</span>
                            <span v-else-if="(haiku.rank || haiku._virtualRank)===1" class="rank-badge"
                                style="background:var(--gold-color);">1ä½
                                {{ settings.everyonePlays ? '' : '(100pt)' }}</span>
                            <span v-else-if="(haiku.rank || haiku._virtualRank)===2" class="rank-badge"
                                style="background:silver;">2ä½
                                {{ settings.everyonePlays ? '' : '(60pt)' }}</span>
                            <span v-else-if="(haiku.rank || haiku._virtualRank)===3" class="rank-badge"
                                style="background:#ad8a80;">3ä½
                                {{ settings.everyonePlays ? '' : '(20pt)' }}</span>
                            <span v-else class="rank-badge" style="background:#eee; color:#666;">
                                {{ (haiku.rank || haiku._virtualRank) ? (haiku.rank || haiku._virtualRank) + 'ä½' :
                                'åœå¤–'
                                }}
                            </span>
                        </div>
                        <div style="font-size:0.8rem;">
                            <!-- ç‚¹æ•°è¡¨ç¤ºONã®å ´åˆ: è©³ç´°è¨ˆç®—å¼ -->
                            <span v-if="settings.showScore">
                                ã‚«ãƒ¼ãƒ‰:{{ haiku.cardScore }} + <span v-if="!settings.everyonePlays">é †ä½:{{
                                    getRankScore(haiku.rank) }} + </span>
                                <span style="color:#e91e63;">â¤ï¸:{{ (haiku.likes ? haiku.likes.length : 0) *
                                    settings.likePoints }}</span> =
                                <b>{{ haiku.totalScore }}pt</b>
                            </span>
                            <!-- ç‚¹æ•°è¡¨ç¤ºOFFã®å ´åˆ: ã‚·ãƒ³ãƒ—ãƒ«è¡¨ç¤º -->
                            <span v-else>
                                <span style="color:#e91e63; font-weight:bold; font-size:1rem;">â¤ï¸ {{ (haiku.likes ?
                                    haiku.likes.length : 0) }}</span>
                            </span>
                        </div>
                    </div>

                    <div style="font-size:1.2rem; font-weight:bold; text-align:center; margin:10px 0;">
                        {{ haiku.top.text }}ã€€{{ haiku.middle.text }}ã€€{{ haiku.bottom.text }}
                    </div>
                    <div style="text-align:right; font-weight:bold; color:var(--sub-color);">
                        è© ï¼š{{ getPlayerName(haiku.userId) }}
                    </div>
                </div>

                <div v-if="isMeMaster && isResultAnimationDone" style="margin-top:20px;">
                    <button class="btn btn-primary" @click="nextRound">æ¬¡ã®å¥ã¸</button>
                </div>
                <div v-if="!isMeMaster && isResultAnimationDone" style="margin-top:20px; text-align:center;">
                    <p>æ¬¡ã®å±•é–‹ã‚’å¾…ã£ã¦ã„ã¾ã™...</p>
                </div>
            </div>
        </div>

        <!-- 3. æœ€çµ‚çµæœ -->
        <div v-else-if="viewState === 'FINISHED'" class="card-box" style="text-align:center;">
            <h2>æœ€çµ‚çµæœ</h2>
            <div v-for="(p, i) in sortedPlayers" :key="p.uid" class="score-row">
                <span>
                    <span v-if="settings.showScore">{{ i+1 }}ä½ </span>
                    {{ p.name }}
                    <span class="heart-count">â¤ï¸ {{ p.totalLikes || 0 }}</span>
                    <!-- å„ªå‹ãƒãƒƒã‚¸ï¼†å›æ•°è¡¨ç¤º -->
                    <span v-if="p.winCount && p.winCount > 0" class="win-badge">
                        <img src="./haiku_badge.png" class="win-icon" alt="ğŸ†"> {{ p.winCount }}å›å„ªå‹
                    </span>
                </span>
                <strong v-if="settings.showScore">{{ p.score }} pt</strong>
            </div>

            <!-- MVPä¿³å¥è¡¨ç¤ºã‚¨ãƒªã‚¢ -->
            <div v-if="topLikedHaikus.length > 0" style="margin-top:30px; text-align:center;">
                <h3 style="color:#e91e63; border-bottom:2px dashed #e91e63; display:inline-block; padding-bottom:5px;">
                    ğŸ† ä»Šæ—¥ã®MVPä¿³å¥ ğŸ†
                </h3>
                <div v-for="(h, idx) in topLikedHaikus" :key="h.id" class="tanzaku"
                    style="margin-bottom:15px; border:2px solid gold; box-shadow:0 0 10px rgba(255, 215, 0, 0.4);">

                    <div style="font-size:0.9rem; font-weight:bold; color:#e91e63; margin-bottom:5px;">
                        {{ idx + 1 }}ä½ (â¤ï¸ {{ h.likes ? h.likes.length : 0 }})
                    </div>

                    <div style="font-size:1.3rem; font-weight:bold; margin:10px 0;">
                        {{ h.top.text }}ã€€{{ h.middle.text }}ã€€{{ h.bottom.text }}
                    </div>

                    <div style="text-align:right; font-weight:bold; color:var(--sub-color); font-size:0.9rem;">
                        è© ï¼š{{ getPlayerName(h.userId) }}
                    </div>
                </div>
            </div>
            <br>
            <br>
            <div v-if="isMeMaster">
                <button class="btn btn-primary" @click="startNextGame">æ¬¡ã®ã‚²ãƒ¼ãƒ ã‚’è¨­å®šã™ã‚‹</button>
            </div>
            <div v-else>
                <p>è¦ªãŒæ¬¡ã®ã‚²ãƒ¼ãƒ ã‚’é–‹å§‹ã™ã‚‹ã®ã‚’å¾…ã£ã¦ã„ã¾ã™...</p>
            </div>
            <div style="margin-top:15px;">
                <button class="btn btn-danger" @click="leaveRoom">éƒ¨å±‹ã‚’æŠœã‘ã‚‹</button>
            </div>


            <div style="margin-top:15px;" v-if="isMeMaster">
                <button class="btn" style="background:var(--oni-color);" @click="addToHallOfFame">
                    ğŸ’¾ æ®¿å ‚å…¥ã‚Šã«ç™»éŒ²
                </button>
            </div>
            <div style="margin-top:15px;">
                <button class="btn" style="background:#888; font-size:0.85rem;" @click="resetRoom">
                    ğŸ—‘ï¸ ãƒ«ãƒ¼ãƒ æƒ…å ±ã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆ
                </button>
            </div>
        </div>

        <!-- 4. æ®¿å ‚å…¥ã‚Šé–²è¦§ç”»é¢ -->
        <div v-else-if="viewState === 'HALL_OF_FAME'" class="card-box" style="text-align:center;">
            <div style="background:var(--oni-color); color:#fff; padding:10px; margin-bottom:15px; border-radius:4px;">
                <h2>ğŸ† æ®¿å ‚å…¥ã‚Š ğŸ†</h2>
            </div>

            <div style="margin-bottom:20px; display:flex; justify-content:center; gap:10px;">
                <button class="btn" @click="closeHallOfFame">æˆ»ã‚‹</button>
                <button class="btn" style="background:#888; font-size:0.8rem;" @click="resetHallOfFame"
                    v-if="hallOfFameList.length > 0">
                    ğŸ—‘ï¸ å…¨ã¦å‰Šé™¤
                </button>
            </div>

            <div v-if="hallOfFameList.length === 0">
                <p>ã¾ã æ®¿å ‚å…¥ã‚Šã®è¨˜éŒ²ã¯ã‚ã‚Šã¾ã›ã‚“ã€‚</p>
            </div>

            <div v-for="record in hallOfFameList" :key="record.id" class="card-box"
                style="margin-bottom:20px; border:1px solid #ddd; text-align:left;">

                <div
                    style="background:#f0f0f0; padding:5px 10px; border-bottom:1px solid #ccc; font-size:0.9rem; display:flex; justify-content:space-between;">
                    <strong>{{ formatDate(record.createdAt) }}</strong>
                    <span>ãƒ«ãƒ¼ãƒ : {{ record.roomId }}</span>
                </div>

                <div style="padding:10px;">
                    <!-- å„ªå‹è€… -->
                    <div style="margin-bottom:10px;">
                        <strong>ğŸ‘‘ å„ªå‹:</strong>
                        <span v-if="record.players && record.players.length > 0">
                            {{ record.players[0].name }} ({{ record.players[0].score }}pt)
                        </span>
                        <span v-else>ä¸æ˜</span>
                    </div>

                    <!-- MVPä¿³å¥ -->
                    <div v-if="record.mvpHaikus && record.mvpHaikus.length > 0">
                        <div style="font-size:0.9rem; font-weight:bold; color:#e91e63; margin-bottom:5px;">
                            [MVPä¿³å¥]
                        </div>
                        <div v-for="(h, i) in record.mvpHaikus" :key="i" class="tanzaku"
                            style="margin-bottom:5px; padding:5px; border:1px solid gold; font-size:1rem;">
                            {{ i+1 }}ä½: {{ h.top.text }} {{ h.middle.text }} {{ h.bottom.text }}
                            <span style="font-size:0.8rem; color:#666;">
                                (è© : {{ getPlayerName(h.userId) }})
                            </span>
                        </div>
                    </div>
                </div>
            </div>
        </div>

        <!-- 5. ä¿³å¥æ¼”å‡ºã‚ªãƒ¼ãƒãƒ¼ãƒ¬ã‚¤ -->
        <transition name="fade">
            <div v-if="showSpecialEffectOverlay && specialEffectHaiku" class="special-overlay">
                <div class="special-content">
                    <div class="special-bg"></div>
                    <div class="special-text">
                        <div class="phrase top">{{ specialEffectHaiku.top.text }}</div>
                        <div class="phrase middle">{{ specialEffectHaiku.middle.text }}</div>
                        <div class="phrase bottom">{{ specialEffectHaiku.bottom.text }}</div>
                    </div>
                    <div class="special-footer">
                        æ¸¾èº«ã®ä¸€å¥ï¼ï¼
                    </div>
                </div>
            </div>
        </transition>

        <!-- ãƒ‡ãƒãƒƒã‚°ãƒ¡ãƒ‹ãƒ¥ãƒ¼ -->
        <!-- ãƒ‡ãƒãƒƒã‚°ãƒ¡ãƒ‹ãƒ¥ãƒ¼ -->
        <div class="debug-panel" v-if="viewState !== 'LOBBY' && isTestMode">
            <div style="font-weight:bold; margin-bottom:5px;">ğŸ› ï¸ ãƒ†ã‚¹ãƒˆ/ãƒ‡ãƒãƒƒã‚°</div>

            <!-- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼åˆ‡ã‚Šæ›¿ãˆã‚¿ãƒ– -->
            <div class="debug-tabs">
                <div v-for="p in players" :key="p.uid" class="debug-tab" :class="{ active: p.uid === myUid }"
                    @click="switchPlayer(p.uid)">
                    {{ p.name }}
                </div>
            </div>

            <div v-if="viewState === 'WAITING'">
                <button class="debug-btn" @click="add3NPCs">ğŸ¤– NPCã‚’3äººè¿½åŠ </button>
            </div>

            <div style="margin-top:5px; border-top:1px solid #555; padding-top:5px;">
                <div style="font-size:0.7rem;">ç¾åœ¨ã®è¦–ç‚¹: <span style="font-weight:bold; color:#e91e63;">{{
                        getPlayerName(myUid)
                        }}</span></div>
                <button class="debug-btn" @click="npcSubmitAll" v-if="gamePhase === 'WRITING'">ğŸ“ ä»–å…¨å“¡æå‡º(å¼·åˆ¶)</button>
                <button class="debug-btn" @click="npcLikeAll" v-if="gamePhase === 'JUDGING'">â¤ï¸ ä»–å…¨å“¡ã„ã„ã­(å¼·åˆ¶)</button>
                <button class="debug-btn" @click="npcMasterJudge"
                    v-if="gamePhase === 'JUDGING' && masterUid && masterUid.startsWith('npc-')">ğŸ‘‘
                    NPCè¦ªæŠ•ç¥¨ï¼†å®Œäº†(å¼·åˆ¶)</button>
            </div>
        </div>
    </div>

    <!-- Vue & Firebase Logic -->
    <script type="module">
        import { createApp } from 'https://unpkg.com/vue@3/dist/vue.esm-browser.js';
        import { initializeApp } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-app.js";
        import { getAuth, signInAnonymously } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-auth.js";
        import {
            getFirestore, collection, doc, getDoc, setDoc, updateDoc,
            onSnapshot, addDoc, arrayUnion, increment, writeBatch, deleteDoc, getDocs
        } from "https://www.gstatic.com/firebasejs/10.7.1/firebase-firestore.js";

        // â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼â–¼
        // ã“ã“ã«ã‚ãªãŸã®Firebase Configã‚’è²¼ã‚Šä»˜ã‘ã¦ãã ã•ã„ï¼
        // â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²â–²
        const firebaseConfig = {
            apiKey: "AIzaSyCQk8FAwozz34jdqoW6wxFqeneaOtA_AP4",
            authDomain: "word-wolf-1432f.firebaseapp.com",
            databaseURL: "https://word-wolf-1432f-default-rtdb.firebaseio.com",
            projectId: "word-wolf-1432f",
            storageBucket: "word-wolf-1432f.firebasestorage.app",
            messagingSenderId: "777084245986",
            appId: "1:777084245986:web:a6976ec8ee22a110dbcbbb"
        };

        let app, auth, db;
        try {
            app = initializeApp(firebaseConfig);
            auth = getAuth(app);
            db = getFirestore(app);
        } catch (e) {
            console.error("Firebase Init Error:", e);
        }

        // --- è¾æ›¸ãƒ‡ãƒ¼ã‚¿ ---
        const WORD_DICTIONARY = [
            // ã€5æ–‡å­— (ä¸Š/ä¸‹)ã€‘é€šå¸¸1ç‚¹, ã‚¹ãƒ‘ã‚¤ã‚¹2-3ç‚¹, é¬¼10ç‚¹
            { text: "å¤¢ã®ä¸­", type: 5, score: 1, isOni: false },
            { text: "ãŠé¢¨å‘‚å ´ã§", type: 5, score: 1, isOni: false },
            { text: "å…¨è£¸å¾…æ©Ÿ", type: 5, score: 10, isOni: true },
            { text: "å³è½ã¡ã§", type: 5, score: 10, isOni: true },
            { text: "ãƒãƒ–ã¿ã‚ã‚‹", type: 5, score: 10, isOni: true },
            { text: "è§¦æ‰‹æ”»ã‚", type: 5, score: 10, isOni: true },

            // ã€7æ–‡å­— (ä¸­)ã€‘
            { text: "å£°ãŒæ¼ã‚Œã¡ã‚ƒã†", type: 7, score: 3, isOni: false },
            { text: "æ±—ã°ã‚“ã è‚Œ", type: 7, score: 2, isOni: false },
            { text: "ã‚¹ã‚«ãƒ¼ãƒˆã¾ãã‚Š", type: 7, score: 3, isOni: false },
            { text: "å£ã«æŠ¼ã—ä»˜ã‘", type: 7, score: 2, isOni: false },
            { text: "è€³å…ƒã§è¨€ã†", type: 7, score: 2, isOni: false },
            { text: "ç†æ€§ãŒé£›ã‚“ã§", type: 7, score: 3, isOni: false },
            { text: "ã‚®ãƒªã‚®ãƒªè¦‹ãˆãŸ", type: 7, score: 2, isOni: false },
            { text: "çµ¶å¯¾æœå¾“", type: 7, score: 3, isOni: false },
            { text: "é™ç•Œã™ãã¦", type: 7, score: 2, isOni: false },
            { text: "çµ¶é ‚è¿ãˆã‚‹", type: 7, score: 3, isOni: false },
            { text: "ç¤¾ä¼šã®çª“ãŒ", type: 7, score: 10, isOni: true },

            // --- ã€è¿½åŠ åˆ†ã€‘5æ–‡å­— (ä¸Š/ä¸‹) ---
            // <æ—¥å¸¸ãƒ»ã‚·ãƒãƒ¥ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³: 1ç‚¹>
            { text: "ä½“è‚²é¤¨", type: 5, score: 1, isOni: false },
            { text: "ä¼šç¤¾ã«ã¦", type: 5, score: 1, isOni: false },
            { text: "ã‚¨ãƒ¬ãƒ™ãƒ¼ã‚¿ãƒ¼", type: 5, score: 1, isOni: false },
            { text: "çµ‚é›»ã§", type: 5, score: 1, isOni: false },
            { text: "é›¨ã®ä¸­", type: 5, score: 1, isOni: false },
            { text: "é£²ã¿ä¼šã§", type: 5, score: 1, isOni: false },
            { text: "ãƒ”ãƒ³ã‚µãƒ­ã§", type: 5, score: 1, isOni: false },
            { text: "æ–‡åŒ–ç¥­", type: 5, score: 1, isOni: false },

            // <ã‚¹ãƒ‘ã‚¤ã‚¹ï¼ˆæ€§ç™–ãƒ»æ„Ÿæƒ…ï¼‰: 2-3ç‚¹>
            { text: "å›£åœ°å¦»", type: 5, score: 2, isOni: false },
            { text: "æ³£ãå«ã¶", type: 5, score: 2, isOni: false },
            { text: "è¸ã‚“ã§ãã‚Œ", type: 5, score: 3, isOni: false },
            { text: "é¦–è¼ªã¤ã‘", type: 5, score: 3, isOni: false },
            { text: "ãƒ ãƒƒãƒãƒ ãƒ", type: 5, score: 2, isOni: false },
            { text: "ä¸»å¾“é–¢ä¿‚", type: 5, score: 3, isOni: false }, // ã˜ã‚…(1)ã˜ã‚…ã†(2)ã‹ã‚“(2)ã‘ã„(2) â€»ãƒªã‚ºãƒ çš„ã«è¨±å®¹ç¯„å›²
            { text: "æ´—è„³æ¸ˆ", type: 5, score: 3, isOni: false },
            { text: "å››ã¤ã‚“é€™ã„", type: 5, score: 3, isOni: false },
            { text: "è‚‰ä¾¿å™¨", type: 5, score: 2, isOni: false },
            { text: "å¯å–ã‚‰ã‚Œã¦", type: 5, score: 3, isOni: false },
            { text: "æ¨ã—ã®å­ãŒ", type: 5, score: 2, isOni: false },
            { text: "å‚¬çœ ã§", type: 5, score: 3, isOni: false },
            { text: "ç„¡è¡¨æƒ…", type: 5, score: 2, isOni: false },
            { text: "é«˜ç¬‘ã„", type: 5, score: 2, isOni: false },
            { text: "ç”Ÿé…ä¿¡", type: 5, score: 2, isOni: false },
            { text: "ä¹³é¦–è²¬ã‚", type: 5, score: 2, isOni: false },
            { text: "ç™¾åˆãˆã£ã¡", type: 5, score: 2, isOni: false },
            { text: "ãŠå¬¢æ§˜", type: 5, score: 2, isOni: false },
            { text: "ãƒ“ãƒ‡ã‚ªãƒ¬ã‚¿ãƒ¼", type: 5, score: 2, isOni: false },
            { text: "ç¾äººç§˜æ›¸", type: 5, score: 2, isOni: false },
            { text: "ãŠã˜ãƒãƒ³ãƒ", type: 5, score: 2, isOni: false },
            { text: "ã‚·ãƒ§ã‚¿ã¡ã‚“ã“", type: 5, score: 2, isOni: false },
            { text: "åˆä½“é¨“", type: 5, score: 2, isOni: false },
            { text: "ç­†ãŠã‚ã—", type: 5, score: 2, isOni: false },
            { text: "æ–­é¢å›³", type: 5, score: 2, isOni: false },
            { text: "ç€è¡£ãˆã‚", type: 5, score: 2, isOni: false },
            { text: "è¦ªå­ä¸¼", type: 5, score: 2, isOni: false },
            { text: "æ„Ÿè¦šé®æ–­", type: 5, score: 2, isOni: false },
            { text: "ã¶ã£ã¨ã‚‚ã‚‚", type: 5, score: 2, isOni: false },
            { text: "ã†ã‚ã‚­ãƒƒãƒ„", type: 5, score: 2, isOni: false },
            { text: "ãƒ•ãƒ«å‹ƒèµ·", type: 5, score: 2, isOni: false },
            { text: "ãƒ¢ãƒ–ãŠã˜ã•ã‚“", type: 5, score: 2, isOni: false },
            { text: "ã‚¨ãƒ­ç¡çœ ", type: 5, score: 2, isOni: false },
            { text: "å§«ã¯ã˜ã‚", type: 5, score: 2, isOni: false },
            { text: "ã†ã‚ãƒ‡ãƒƒã‚«", type: 5, score: 3, isOni: false },
            { text: "å¹´é½¢å·®", type: 5, score: 2, isOni: false },
            { text: "åœ°å‘³çœ¼é¡", type: 5, score: 3, isOni: false },
            { text: "ä½“æ ¼å·®", type: 5, score: 2, isOni: false },
            { text: "çµŒç”£å©¦", type: 5, score: 2, isOni: false },
            { text: "ç™ºæƒ…æœŸ", type: 5, score: 2, isOni: false },
            { text: "ã‚ªãƒŠãƒ›ã°ã‚Œ", type: 5, score: 5, isOni: false },
            { text: "æŠ¼ã—å€’ã—", type: 5, score: 2, isOni: false },
            { text: "è¡Œããšã‚Šã®", type: 5, score: 2, isOni: false },
            { text: "ãƒã‚¤ã‚¢ã‚°ãƒ©", type: 5, score: 2, isOni: false },
            { text: "ãƒ‘ã‚¤ã‚ºãƒªã§", type: 5, score: 2, isOni: false },
            { text: "ç«‹ã¡ãƒãƒƒã‚¯", type: 5, score: 2, isOni: false },
            { text: "æ—¦é‚£æ§˜", type: 5, score: 2, isOni: false },
            { text: "ã‚¤ã‚±ãƒ¡ãƒ³ã¨", type: 5, score: 5, isOni: false },
            { text: "ãŠãƒ‘ãƒ³ãƒ†ã‚£", type: 5, score: 2, isOni: false },
            { text: "ã©å¤‰æ…‹", type: 5, score: 2, isOni: false },
            { text: "ä»Šæ—¥ã—ã‚ˆã†â¤", type: 5, score: 2, isOni: false },
            { text: "ä¸­ã§ã„ã„ã‚ˆâ¤", type: 5, score: 2, isOni: false },
            { text: "ãƒ‘ãƒ³â¤ãƒ‘ãƒ³â¤ãƒ‘ãƒ³â¤", type: 5, score: 2, isOni: false },
            { text: "Oh.YES", type: 5, score: 5, isOni: false },
            { text: "ã©ã³ã‚…ã‚‹ã‚‹ã‚‹", type: 5, score: 3, isOni: false },
            { text: "ãã£ã¡ã‚‡ãã¡ã‚‡", type: 5, score: 2, isOni: false },
            { text: "ã¶ã¼ã¼ã‚‚ã‚ã", type: 5, score: 8, isOni: false },
            { text: "ãŠã¾ã‚“ã“ã«", type: 5, score: 2, isOni: false },
            { text: "ã‚±ãƒ„ã‚’å‡ºã›", type: 5, score: 5, isOni: false },
            { text: "é¢¨ä¿—å¬¢", type: 5, score: 2, isOni: false },
            { text: "äº¤å°¾ä¸­", type: 5, score: 2, isOni: false },
            { text: "ã‚„ãƒ»ã‚‰ãƒ»ãªãƒ»ã„ãƒ»ã‹", type: 5, score: 8, isOni: false },
            { text: "é¢¨ä¿—å¬¢", type: 5, score: 2, isOni: false },
            { text: "å¥³ç‹æ§˜", type: 5, score: 2, isOni: false },
            { text: "æ‹˜æŸå…·", type: 5, score: 5, isOni: false },
            { text: "è‰²ä»•æ›ã‘", type: 5, score: 2, isOni: false },
            { text: "è¨€è‘‰è²¬ã‚", type: 5, score: 2, isOni: false },
            { text: "èª˜ã„å—ã‘", type: 5, score: 2, isOni: false },
            { text: "VTuber", type: 5, score: 5, isOni: false },
            { text: "ã¬ã‚‹ã£ã¬ã‚‹", type: 5, score: 3, isOni: false },
            { text: "ãƒŒã·ã·ã·ã·ãƒƒ", type: 5, score: 7, isOni: false },
            { text: "ã¡ã‚“ã‚ãªã”", type: 5, score: 2, isOni: false },
            { text: "ä¸€æ™‚é–“", type: 5, score: 2, isOni: false },
            { text: "ã‚¹ã‚±ãƒ™æ¤…å­", type: 5, score: 2, isOni: false },
            { text: "éš ã—æ’®ã‚Š", type: 5, score: 4, isOni: false },
            { text: "ã¾ã‚“ã“ãã±ã", type: 5, score: 2, isOni: false },
            { text: "éœ²å‡ºç‹‚", type: 5, score: 2, isOni: false },
            { text: "ã‚¨ãƒãƒã‚°ãƒ©", type: 5, score: 5, isOni: false },
            { text: "çŒ¿ãã¤ã‚", type: 5, score: 2, isOni: false },
            { text: "ä¸å€«è¡Œç‚º", type: 5, score: 2, isOni: false },
            { text: "ã‚ã‚“â¤ã‚ã‚“â¤ã‚ã‚“â¤", type: 5, score: 2, isOni: false },

            // <é¬¼æœ­ï¼ˆé«˜å¾—ç‚¹ãƒ»ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆï¼‰: 10ç‚¹>
            { text: "ãƒ‡ã‚¹ã‚¢ã‚¯ãƒ¡", type: 5, score: 10, isOni: true },
            { text: "ã‚±ãƒ„ã‚¢ã‚¯ãƒ¡", type: 5, score: 10, isOni: true },
            { text: "ãƒ•ãƒ«å‹ƒèµ·", type: 5, score: 10, isOni: true },
            { text: "é»’æ­´å²", type: 5, score: 10, isOni: true },
            { text: "ã‚¶ã‚³ã¾ã‚“ã“", type: 5, score: 10, isOni: true },
            { text: "å°Šå³ç ´å£Š", type: 5, score: 10, isOni: true },
            { text: "é¬±å‹ƒèµ·", type: 5, score: 10, isOni: true },
            { text: "äºŒç©´è²¬ã‚", type: 5, score: 10, isOni: true },
            { text: "æˆä¹³ã‚³ã‚­", type: 5, score: 10, isOni: true },
            { text: "é€†ãƒ¬ã‚¤ãƒ—", type: 5, score: 10, isOni: true },
            { text: "ç„¡æ§˜ã‚¨ãƒ­", type: 5, score: 10, isOni: true },
            { text: "ã‚¤ãƒãƒ©ãƒã‚ª", type: 5, score: 10, isOni: true },
            { text: "ã‚ã‚“ãŸãƒã‚«ãï¼Ÿ", type: 5, score: 20, isOni: true },
            { text: "ãƒ¦ãƒ‹ã‚³ãƒ¼ãƒ³ï¼ï¼", type: 5, score: 15, isOni: true },
            { text: "ã‚„ã‚‰ã›ã¯ã›ã‚“", type: 5, score: 10, isOni: true },

            // --- ã€è¿½åŠ åˆ†ã€‘7æ–‡å­— (ä¸­) ---
            // <æ—¥å¸¸ãƒ»ã‚·ãƒãƒ¥ã‚¨ãƒ¼ã‚·ãƒ§ãƒ³: 1ç‚¹>
            { text: "è„šãƒ”ãƒ³ã‚ªãƒŠãƒ‹ãƒ¼", type: 7, score: 1, isOni: false }, // å­—ä½™ã‚Šã ãŒå‹¢ã„
            { text: "åˆ†ã‹ã‚‰ã›ãˆã£ã¡", type: 7, score: 1, isOni: false },
            { text: "å¯å–ã‚‰ã‚Œå ±å‘Š", type: 7, score: 1, isOni: false },
            { text: "å­ä½œã‚Šãˆã£ã¡", type: 7, score: 1, isOni: false },
            { text: "è£¸ã‚¨ãƒ—ãƒ­ãƒ³", type: 7, score: 1, isOni: false },

            // <ã‚¹ãƒ‘ã‚¤ã‚¹ï¼ˆæ€§ç™–ãƒ»æ„Ÿæƒ…ï¼‰: 2-3ç‚¹>
            { text: "å°„ç²¾æ‡‡é¡˜", type: 7, score: 2, isOni: false },
            { text: "é™¥æ²¡ä¹³é¦–", type: 7, score: 3, isOni: false },
            { text: "å°„ç²¾ç®¡ç†ã§", type: 7, score: 3, isOni: false },
            { text: "Må­—é–‹è„š", type: 7, score: 3, isOni: false },
            { text: "é€£ç¶šçµ¶é ‚", type: 7, score: 2, isOni: false },
            { text: "çµ¶å«ç—™æ”£", type: 7, score: 3, isOni: false },
            { text: "ãŠã—ã£ã“æˆ‘æ…¢", type: 7, score: 3, isOni: false },
            { text: "ã´ã£ã¡ã‚Šã‚¹ãƒ¼ãƒ„", type: 7, score: 2, isOni: false },
            { text: "ç¡çœ ã‚¢ãƒ—ãƒª", type: 7, score: 3, isOni: false },
            { text: "æ„Ÿåº¦åƒå€", type: 7, score: 3, isOni: false },
            { text: "é€†ãƒ¬ã‚¤ãƒ—", type: 7, score: 2, isOni: false },
            { text: "ãŠã¡ã‚“ã½ã¿ã‚‹ã", type: 7, score: 5, isOni: false },
            { text: "ã‚¢ãƒŠãƒ«ã‚»ãƒƒã‚¯ã‚¹", type: 7, score: 5, isOni: false },
            { text: "ã‚·ãƒƒã‚¯ã‚¹ãƒŠã‚¤ãƒ³", type: 7, score: 5, isOni: false },
            { text: "ãƒ‹ãƒ—ãƒ«ãƒ•ã‚¡ãƒƒã‚¯", type: 7, score: 2, isOni: false },
            { text: "ãƒ•ã‚£ã‚¹ãƒˆãƒ•ã‚¡ãƒƒã‚¯", type: 7, score: 2, isOni: false },
            { text: "å£å†…å°„ç²¾", type: 7, score: 2, isOni: false },
            { text: "æ´åŠ©äº¤éš›", type: 7, score: 2, isOni: false },
            { text: "è¤‡æ•°ãƒ—ãƒ¬ã‚¤", type: 7, score: 2, isOni: false },
            { text: "é¡”é¢é¨ä¹—", type: 7, score: 2, isOni: false },
            { text: "ã‚¯ãƒ³ãƒ‹ãƒªãƒ³ã‚°ã‚¹", type: 7, score: 2, isOni: false },
            { text: "ã¾ã‚“ãã‚Šè¿”ã—", type: 7, score: 2, isOni: false },
            { text: "ã‚ªãƒŠãƒ›ã‚’ä½¿ã£ã¦", type: 7, score: 2, isOni: false },
            { text: "éš£ã®éƒ¨å±‹ã§", type: 7, score: 2, isOni: false },
            { text: "ã‚¢ãƒ˜é¡”æ™’ã™", type: 7, score: 4, isOni: false },
            { text: "ãƒ“ãƒ‡ã‚ªå›ã—ã¦", type: 7, score: 2, isOni: false },
            { text: "è¨€ã„ãªã‚Šã«ãªã‚‹", type: 7, score: 2, isOni: false },
            { text: "ä½•åº¦ã‚‚ã‚¤ã£ã¡ã‚ƒã†", type: 7, score: 2, isOni: false },
            { text: "ãƒŠã‚«ã§æš´ã‚Œã‚‹", type: 7, score: 2, isOni: false },
            { text: "ã‚¬ãƒãƒ³ã§ããšã«", type: 7, score: 2, isOni: false },
            { text: "æ°—æŒã¡ã‚ˆã™ãã¦", type: 7, score: 2, isOni: false },
            { text: "å¥¥ã¾ã§å±Šã", type: 7, score: 2, isOni: false },
            { text: "è…°ãŒç •ã‘ã‚‹", type: 7, score: 3, isOni: false },
            { text: "å¥³ã‚’æŠ±ã„ã¦", type: 7, score: 2, isOni: false },
            { text: "é¨ä¹—ä½ã‚­ãƒ¡ã¦", type: 7, score: 4, isOni: false },
            { text: "ã„ã¡ã‚ƒã‚‰ã¶ãˆã£ã¡", type: 7, score: 3, isOni: false },
            { text: "ãƒã‚­ãƒã‚­ç«¥è²", type: 7, score: 6, isOni: false },
            { text: "ã‚¢ãƒŠãƒ«ãªã‚ãªã‚", type: 7, score: 5, isOni: false },
            { text: "ãƒ”ã‚¹ãƒˆãƒ³é‹å‹•", type: 7, score: 2, isOni: false },
            { text: "ãƒãƒ³ã‚³ã‚’èˆã‚ã‚‹", type: 7, score: 2, isOni: false },
            { text: "ãŒã‚“ã°ã‚Œâ¤ãŒã‚“ã°ã‚Œâ¤", type: 7, score: 2, isOni: false },
            { text: "ãƒ­ãƒ¼ã‚·ãƒ§ãƒ³ãƒ—ãƒ¬ã‚¤", type: 7, score: 2, isOni: false },
            { text: "ãƒ­ãƒ¼ã‚¿ãƒ¼æ•£æ­©", type: 7, score: 4, isOni: false },
            { text: "ç•°ç‰©æŒ¿å…¥", type: 7, score: 7, isOni: false },
            { text: "ãƒã‚¤ãƒ–ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³", type: 7, score: 2, isOni: false },
            { text: "ã‚¹ãƒ‘ãƒ³ã‚­ãƒ³ã‚°ã§", type: 7, score: 2, isOni: false },
            { text: "ã½ã“ã¡ã‚“è¹´ã‚Šä¸Šã’", type: 7, score: 9, isOni: false },
            { text: "åŒé ­ãƒ‡ã‚£ãƒ«ãƒ‰", type: 7, score: 2, isOni: false },
            { text: "å³ãƒãƒ¡ãˆã£ã¡", type: 7, score: 2, isOni: false },
            { text: "ãƒ¯ãƒ³ãƒŠã‚¤ãƒˆãƒ©ãƒ–", type: 7, score: 2, isOni: false },
            { text: "æ•°ã®å­å¤©äº•", type: 7, score: 2, isOni: false },
            { text: "ä»®æ€§åŒ…èŒ", type: 7, score: 2, isOni: false },
            { text: "ãƒ‰ãƒªãƒ«ã¡ã‚“ã¡ã‚“", type: 7, score: 5, isOni: false },
            { text: "å°»ã‚³ã‚­ãˆã£ã¡", type: 7, score: 2, isOni: false },
            { text: "è¶³ã‚³ã‚­ãˆã£ã¡", type: 7, score: 2, isOni: false },
            { text: "ãƒ‘ã‚¤ã‚ºãƒªãˆã£ã¡", type: 7, score: 2, isOni: false },
            { text: "ã†ã‚‹ã›ã‡!!ã„ã“ã†!!", type: 7, score: 6, isOni: false },
            { text: "å¿ƒã‚’ç‡ƒã‚„ã›", type: 7, score: 5, isOni: false },
            { text: "é§…å¼å¤§å¥½ãâ¤", type: 7, score: 5, isOni: false },
            { text: "ãƒ‡ã‚£ãƒ¼ãƒ—ã‚¹ãƒ­ãƒ¼ãƒˆ", type: 7, score: 2, isOni: false },
            { text: "ä¸€äººå°ºå…«", type: 7, score: 2, isOni: false },
            { text: "ä¸­å‡ºã—ã‚»ãƒƒã‚¯ã‚¹", type: 7, score: 2, isOni: false },
            { text: "å­ä½œã‚Šã‚»ãƒƒã‚¯ã‚¹", type: 7, score: 4, isOni: false },
            { text: "ãƒ”ãƒ³ã‚¯ãƒ­ãƒ¼ã‚¿ãƒ¼", type: 7, score: 2, isOni: false },
            { text: "ä¸‰è§’æœ¨é¦¬", type: 7, score: 2, isOni: false },
            { text: "ã‚ªãƒ›å£°éŸ¿ã", type: 7, score: 2, isOni: false },
            { text: "ä¸€ç”Ÿæ‡¸å‘½", type: 7, score: 2, isOni: false },
            { text: "å…¬è¡†é¢å‰", type: 7, score: 3, isOni: false },
            { text: "å…¬è¡†ãƒˆã‚¤ãƒ¬", type: 7, score: 3, isOni: false },
            { text: "äº€ç”²ç¸›ã‚Š", type: 7, score: 2, isOni: false },
            { text: "ãƒãƒ³ã‚«ã‚¹é¦™ã‚‹", type: 7, score: 2, isOni: false },
            { text: "ã½ã“ã¡ã‚“ãƒ•ã‚£ãƒ¼ãƒãƒ¼", type: 7, score: 6, isOni: false },
            { text: "ãŠã—ã‚Šã‚’èˆã‚ã‚‹", type: 7, score: 2, isOni: false },
            { text: "å­å®®æ‹æ„›", type: 7, score: 2, isOni: false },
            { text: "ã‚¤ã‚¯â¤ã‚¤ã‚¯â¤ã‚¤ã£ã¡ã‚ƒã†â¤", type: 7, score: 6, isOni: false },
            { text: "ããæ‰“ã¡é¨ä¹—ä½", type: 7, score: 4, isOni: false },
            { text: "é™¤æ¯›ãƒ—ãƒ¬ã‚¤ã§", type: 7, score: 2, isOni: false },
            { text: "æ‹˜æŸé›»ãƒ", type: 7, score: 2, isOni: false },
            { text: "é«˜é€Ÿãƒ”ã‚¹ãƒˆãƒ³", type: 7, score: 2, isOni: false },


            // <é¬¼æœ­ï¼ˆé«˜å¾—ç‚¹ãƒ»ã‚¤ãƒ³ãƒ‘ã‚¯ãƒˆï¼‰: 10ç‚¹>
            { text: "ç¨®ä»˜ã‘ãƒ—ãƒ¬ã‚¹", type: 7, score: 10, isOni: true }, // ã‚¬ãƒãƒ£ç”¨èª
            { text: "å°„ç²¾æ‡‡é¡˜", type: 7, score: 10, isOni: true },
            { text: "å¤§é‡å¤±ç¦", type: 7, score: 10, isOni: true },
            { text: "ãµãŸãªã‚Šå·¨ä¹³", type: 7, score: 15, isOni: true },
            { text: "ãƒãƒ³åªšãƒ€ãƒ³ã‚¹", type: 7, score: 10, isOni: true },
            { text: "ã ã„ã—ã‚…ããƒ›ãƒ¼ãƒ«ãƒ‰", type: 7, score: 10, isOni: true },
            { text: "ç¸¦å‰²ã‚Œã‚ãªã‚‹", type: 7, score: 10, isOni: true },
            { text: "æ¿ç‚¹å–˜ã", type: 7, score: 10, isOni: true },
            { text: "å¿«æ¥½æ‹·å•", type: 7, score: 10, isOni: true },
            { text: "ã‚¢ãƒ˜é¡”ãƒ€ãƒ–ãƒ”", type: 7, score: 10, isOni: true },
            { text: "ã¾ã•ã‹ãƒ»ãƒ»ãƒ»æš´èµ°!?", type: 7, score: 20, isOni: true },

        ];

        // é…æœ­ãƒ­ã‚¸ãƒƒã‚¯ (Util)
        // å¼•æ•°ã§æšæ•°ã‚’æŒ‡å®šå¯èƒ½ã«ã™ã‚‹ (ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆ: 5æ–‡å­—=5æš, 7æ–‡å­—=7æš)
        function generateHand(count5 = 5, count7 = 7) {
            const fives = WORD_DICTIONARY.filter(w => w.type === 5);
            const sevens = WORD_DICTIONARY.filter(w => w.type === 7);

            const pick = (arr, count) => {
                const shuffled = [...arr].sort(() => 0.5 - Math.random());
                // IDã‚’ä»˜ä¸
                return shuffled.slice(0, count).map(w => ({ ...w, id: Math.random().toString(36).substr(2, 9) }));
            };

            // æŒ‡å®šæšæ•°é…å¸ƒ
            return {
                fives: pick(fives, count5),
                sevens: pick(sevens, count7)
            };
        }

        createApp({
            data() {
                return {
                    viewState: 'LOBBY',
                    gamePhase: 'WRITING',

                    myPlayerName: '',
                    roomId: '',
                    myUid: '',

                    players: [],
                    masterHistory: [],
                    roundCount: 1,
                    masterUid: '',

                    gameCount: 1,

                    currentHaikus: [],
                    allGameHaikus: [], // ã‚²ãƒ¼ãƒ å…¨ä½“ã®ä¿³å¥ï¼ˆMVPé¸å‡ºç”¨ï¼‰
                    myDraft: { top: null, middle: null, bottom: null },

                    // æ¼”å‡ºç”¨
                    useSpecialEffect: false,
                    showSpecialEffectOverlay: false,
                    specialEffectHaiku: null,
                    specialEffectQueue: [], // è¤‡æ•°ã®æ¼”å‡ºç”¨ã‚­ãƒ¥ãƒ¼
                    isSpecialEffectDone: false, // æ¼”å‡ºå†ç”Ÿæ¸ˆã¿ãƒ•ãƒ©ã‚°

                    freeInputText: '',
                    freeInputType: 5,

                    isLoading: false,
                    errorMessage: '',

                    visibleResultCount: 0,
                    isResultAnimationDone: false,
                    tempRankState: {},

                    unsubRoom: null,
                    unsubHaikus: null,

                    // æ¥ç¶šå®‰å®šåŒ–ç”¨
                    isReconnecting: false,
                    connectionStatus: 'offline',
                    connectionStatus: 'offline',
                    lastError: null,

                    isTestMode: false,

                    // è¨­å®šãƒ»ã‚¿ã‚¤ãƒãƒ¼
                    settings: {
                        timeLimit: 300, // ç§’
                        showMaster: true,
                        showScore: true,
                        likePoints: 10,
                        everyonePlays: false,
                        handSizeFive: 5,
                        handSizeSeven: 5
                    },
                    tempSettings: { // ç·¨é›†ç”¨
                        timeLimitMin: 5,
                        showMaster: true,
                        showScore: true,
                        likePoints: 10,
                        everyonePlays: false,
                        handSizeFive: 5,
                        handSizeSeven: 5
                    },
                    roundStartTime: null,
                    timeLeft: 0,
                    timerInterval: null
                };
            },
            computed: {
                isMeMaster() { return this.myUid === this.masterUid; },

                myHand() {
                    const p = this.players.find(x => x.uid === this.myUid);
                    return p ? p.hand : { fives: [], sevens: [] };
                },
                hasCreatedFreeCard() {
                    if (!this.myHand) return false;
                    return (this.myHand.fives.some(c => c.isFree) || this.myHand.sevens.some(c => c.isFree));
                },
                currentDraftScore() {
                    let s = 0;
                    if (this.myDraft.top) s += this.myDraft.top.score;
                    if (this.myDraft.middle) s += this.myDraft.middle.score;
                    if (this.myDraft.bottom) s += this.myDraft.bottom.score;
                    return s;
                },
                hasSubmitted() {
                    return this.currentHaikus.some(h => h.userId === this.myUid);
                },
                submittedCount() {
                    return this.currentHaikus.length;
                },
                canFinalize() {
                    if (this.settings.everyonePlays) return true;
                    const ranks = Object.values(this.tempRankState);
                    const needed = Math.min(3, this.currentHaikus.length);
                    return ranks.length >= needed;
                },
                sortedHaikusForJudging() {
                    const list = [...this.currentHaikus];
                    // æ¼”å‡ºä»˜ãã®ä¿³å¥ã‚’å…ˆé ­ã«ã™ã‚‹
                    // ã‹ã¤ã€é€šå¸¸ã¯ãƒ©ãƒ³ãƒ€ãƒ 
                    list.sort((a, b) => {
                        if (a.isSpecial && !b.isSpecial) return -1;
                        if (!a.isSpecial && b.isSpecial) return 1;
                        // ä¸¡æ–¹Special or ä¸¡æ–¹Normalãªã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã‚­ãƒ¼ã§ã‚½ãƒ¼ãƒˆ
                        return (a.randomSortKey || 0) - (b.randomSortKey || 0);
                    });
                    return list;
                },
                sortedHaikusForDisplay() {
                    const hasRanks = this.currentHaikus.some(h => h.rank && h.rank > 0);
                    if (this.settings.everyonePlays || !hasRanks) {
                        const sorted = [...this.currentHaikus].sort((a, b) => (b.totalScore || 0) - (a.totalScore || 0));
                        return sorted.map((h, i) => ({ ...h, _virtualRank: i + 1 }));
                    }
                    return [...this.currentHaikus].sort((a, b) => (a.rank || 999) - (b.rank || 999));
                },
                sortedPlayers() {
                    if (this.settings.showScore) {
                        return [...this.players].sort((a, b) => b.score - a.score);
                    }
                    return this.players;
                },
                // è‡ªåˆ†ãŒã„ã„ã­ã‚’æ—¢ã«ã—ã¦ã„ã‚‹ã‹ï¼ˆ1å›åˆ¶é™ãƒã‚§ãƒƒã‚¯ç”¨ï¼‰
                hasLikedAny() {
                    return this.currentHaikus.some(h => h.likes && h.likes.includes(this.myUid));
                },
                likedCount() {
                    const uids = new Set();
                    this.currentHaikus.forEach(h => {
                        if (h.likes) {
                            h.likes.forEach(uid => uids.add(uid));
                        }
                    });
                    return uids.size;
                },
                likeTargetCount() {
                    return this.settings.everyonePlays ? this.players.length : (this.players.length - 1);
                },

                hasMySpecialEffectUsed() {
                    if (!this.myUid) return false;
                    const p = this.players.find(p => p.uid === this.myUid);
                    return p ? !!p.specialEffectUsed : false;
                },

                // å…¨ãƒ©ã‚¦ãƒ³ãƒ‰é€šã—ã¦ã®MVPä¿³å¥ï¼ˆã„ã„ã­æ•°é † -> ç‚¹æ•°é †ï¼‰
                topLikedHaikus() {
                    if (!this.allGameHaikus || this.allGameHaikus.length === 0) return [];

                    // ç¾åœ¨ã®ã‚²ãƒ¼ãƒ (gameCount)ã®ä¿³å¥ã®ã¿å¯¾è±¡
                    const target = this.allGameHaikus.filter(h => h.gameCount === this.gameCount);

                    // ã‚½ãƒ¼ãƒˆ: ã„ã„ã­æ•°(é™é †) > ç‚¹æ•°(é™é †)
                    return target.sort((a, b) => {
                        const likeA = a.likes ? a.likes.length : 0;
                        const likeB = b.likes ? b.likes.length : 0;
                        if (likeA !== likeB) return likeB - likeA;
                        return (b.totalScore || 0) - (a.totalScore || 0);
                    }).slice(0, 3); // ä¸Šä½3ã¤
                }
            },

            // ãƒšãƒ¼ã‚¸èª­ã¿è¾¼ã¿æ™‚ã«è‡ªå‹•å¾©å¸°ã‚’è©¦ã¿ã‚‹
            async mounted() {
                await this.tryAutoReconnect();
            },

            methods: {
                // --- ã‚»ãƒƒã‚·ãƒ§ãƒ³ç®¡ç† ---
                saveSession() {
                    const sessionData = {
                        roomId: this.roomId,
                        playerName: this.myPlayerName,
                        uid: this.myUid,
                        isTestMode: this.isTestMode,
                        timestamp: Date.now()
                    };
                    localStorage.setItem('haikuGameSession', JSON.stringify(sessionData));
                },

                loadSession() {
                    try {
                        const saved = localStorage.getItem('haikuGameSession');
                        if (!saved) return null;
                        const session = JSON.parse(saved);
                        // 24æ™‚é–“ä»¥å†…ã®ã‚»ãƒƒã‚·ãƒ§ãƒ³ã®ã¿æœ‰åŠ¹
                        if (Date.now() - session.timestamp > 24 * 60 * 60 * 1000) {
                            localStorage.removeItem('haikuGameSession');
                            return null;
                        }
                        return session;
                    } catch (e) {
                        return null;
                    }
                },

                clearSession() {
                    localStorage.removeItem('haikuGameSession');
                },

                // --- è‡ªå‹•å¾©å¸°ï¼ˆãƒšãƒ¼ã‚¸ãƒªãƒ­ãƒ¼ãƒ‰å¯¾å¿œï¼‰ ---
                async tryAutoReconnect() {
                    const session = this.loadSession();
                    if (!session) return false;

                    this.isReconnecting = true;
                    this.connectionStatus = 'reconnecting';

                    try {
                        // Firebaseèªè¨¼çŠ¶æ…‹ã‚’ç¢ºèªãƒ»å¾©å¸°
                        const userCred = await signInAnonymously(auth);
                        this.myUid = userCred.user.uid;

                        // éƒ¨å±‹ãŒå­˜åœ¨ã™ã‚‹ã‹ç¢ºèª
                        const roomRef = doc(db, "rooms", session.roomId);
                        const roomSnap = await getDoc(roomRef);

                        if (roomSnap.exists()) {
                            const data = roomSnap.data();
                            // è‡ªåˆ†ãŒã¾ã éƒ¨å±‹ã«ã„ã‚‹ã‹ç¢ºèªï¼ˆUIDã¾ãŸã¯åå‰ã§ç…§åˆï¼‰
                            let myPlayer = data.players.find(p => p.uid === session.uid);
                            if (!myPlayer) {
                                myPlayer = data.players.find(p => p.name === session.playerName);
                            }

                            if (myPlayer) {
                                this.roomId = session.roomId;
                                this.myPlayerName = myPlayer.name;
                                this.myUid = myPlayer.uid;
                                this.isTestMode = session.isTestMode || false;

                                // ã‚»ãƒƒã‚·ãƒ§ãƒ³æ›´æ–°
                                this.saveSession();

                                this.startRoomListener();
                                this.viewState = 'GAME';
                                this.connectionStatus = 'online';
                                this.isReconnecting = false;
                                console.log('ã‚»ãƒƒã‚·ãƒ§ãƒ³å¾©å¸°æˆåŠŸ');
                                return true;
                            }
                        }
                    } catch (e) {
                        console.warn('è‡ªå‹•å¾©å¸°å¤±æ•—:', e);
                    }

                    this.isReconnecting = false;
                    this.connectionStatus = 'offline';
                    this.clearSession();
                    return false;
                },

                // ãƒ­ãƒ“ãƒ¼æ©Ÿèƒ½
                hallOfFameList: [],

                // ãƒ­ãƒ“ãƒ¼æ©Ÿèƒ½ --- 
                async enterRoom() {
                    if (!db) { this.errorMessage = "Firebaseè¨­å®šãŒã‚ã‚Šã¾ã›ã‚“"; return; }
                    this.isLoading = true;
                    this.errorMessage = '';
                    this.lastError = null;

                    try {
                        const userCred = await signInAnonymously(auth);
                        this.myUid = userCred.user.uid;

                        const roomRef = doc(db, "rooms", this.roomId);
                        const roomSnap = await getDoc(roomRef);

                        const initialHand = generateHand();
                        const newPlayer = {
                            uid: this.myUid,
                            name: this.myPlayerName,
                            score: 0,
                            totalLikes: 0,
                            winCount: 0, // å„ªå‹å›æ•°åˆæœŸåŒ–
                            hand: initialHand
                        };

                        if (!roomSnap.exists()) {
                            // æ–°è¦ä½œæˆ
                            await setDoc(roomRef, {
                                roomId: this.roomId,
                                status: 'WAITING', // å¾…æ©ŸçŠ¶æ…‹ã‹ã‚‰ã‚¹ã‚¿ãƒ¼ãƒˆ
                                gameCount: 1,
                                roundCount: 1,
                                masterUid: this.myUid,
                                masterHistory: [this.myUid],
                                players: [newPlayer],
                                settings: {
                                    timeLimit: 300,
                                    showMaster: true,
                                    showScore: true,
                                    likePoints: 10,
                                    everyonePlays: false,
                                    handSizeFive: 5, // 5æ–‡å­—ã‚«ãƒ¼ãƒ‰æšæ•°
                                    handSizeSeven: 5  // 7æ–‡å­—ã‚«ãƒ¼ãƒ‰æšæ•°
                                },
                                roundStartTime: null
                            });
                        } else {
                            // å‚åŠ 
                            const data = roomSnap.data();
                            const existing = data.players.find(p => p.uid === this.myUid);
                            if (!existing) {
                                await updateDoc(roomRef, {
                                    players: arrayUnion(newPlayer)
                                });
                            }
                        }

                        // ã‚»ãƒƒã‚·ãƒ§ãƒ³ä¿å­˜
                        this.saveSession();
                        this.connectionStatus = 'online';

                        this.startRoomListener();
                        // viewStateã¯ãƒªã‚¹ãƒŠãƒ¼ã®statusã‚’è¦‹ã¦æ›´æ–°ã•ã‚Œã‚‹ã®ã§ã“ã“ã§ã¯ä»®è¨­å®šã—ãªã„ã€
                        // ã¾ãŸã¯WAITINGã¨ã—ã¦ãŠã
                        this.viewState = 'WAITING';

                    } catch (e) {
                        console.error(e);
                        this.errorMessage = "ã‚¨ãƒ©ãƒ¼: " + e.message;
                        this.lastError = e;
                        this.connectionStatus = 'offline';
                    } finally {
                        this.isLoading = false;
                    }
                },

                // --- Firestoreç›£è¦–ï¼ˆãƒªã‚¹ãƒŠãƒ¼é‡è¤‡é˜²æ­¢ä»˜ãï¼‰ ---
                startRoomListener() {
                    // æ—¢å­˜ã®ãƒªã‚¹ãƒŠãƒ¼ãŒã‚ã‚Œã°è§£é™¤ï¼ˆé‡è¤‡é˜²æ­¢ï¼‰
                    if (this.unsubRoom) {
                        this.unsubRoom();
                        this.unsubRoom = null;
                    }
                    if (this.unsubHaikus) {
                        this.unsubHaikus();
                        this.unsubHaikus = null;
                    }

                    // Roomç›£è¦–
                    this.unsubRoom = onSnapshot(doc(db, "rooms", this.roomId), (docSnap) => {
                        if (!docSnap.exists()) return;
                        const data = docSnap.data();

                        this.players = data.players || [];
                        this.roundCount = data.roundCount;
                        this.masterUid = data.masterUid;
                        this.masterHistory = data.masterHistory || [];
                        this.gameCount = data.gameCount || 1;
                        this.connectionStatus = 'online';
                        this.roundStartTime = data.roundStartTime || null;

                        console.log('Room update:', data); // DEBUG
                        console.log('Current Phase:', this.gamePhase, 'New Status:', data.status); // DEBUG

                        // è¨­å®šåŒæœŸ
                        if (data.settings) {
                            this.settings = {
                                timeLimit: 300,
                                showMaster: true,
                                showScore: true,
                                likePoints: 10,
                                everyonePlays: false,
                                ...data.settings
                            };
                            // ç·¨é›†ç”¨å¤‰æ•°ã«ã‚‚åæ˜ ï¼ˆè‡ªåˆ†ãŒãƒ›ã‚¹ãƒˆã§ç·¨é›†ä¸­ã§ãªã„å ´åˆ...ã¯é›£ã—ã„ã®ã§ã€ã¨ã‚Šã‚ãˆãšåŒæœŸï¼‰
                            // è‡ªåˆ†ãŒç·¨é›†ä¸­ã®å ´åˆã€ãƒ«ãƒ¼ãƒ—ã—ãªã„ã‚ˆã†ã«å°‘ã—å·¥å¤«ãŒå¿…è¦ã ãŒã€
                            // ä»Šå›ã¯å˜ç´”ã«åŒæœŸã™ã‚‹ï¼ˆä»–äººãŒå¤‰ãˆã‚‹ã“ã¨ã¯ãªã„å‰æï¼‰
                            if (!this.isMeMaster) {
                                // é–²è¦§è€…ã¯å¸¸ã«DBã®å€¤ã‚’è¦‹ã‚‹
                            } else {
                                // ãƒ›ã‚¹ãƒˆã‚‚DBã®å€¤ãŒæ­£ã ãŒã€UIå…¥åŠ›ç”¨ã«å¤‰æ›
                                // â€»å…¥åŠ›ä¸­ã¯ã“ã“ãŒé »ç¹ã«æ›´æ–°ã•ã‚Œã‚‹ã¨ä½¿ã„ã«ãã„ãŒã€
                                // DBæ›´æ–°ã¯changeã‚¤ãƒ™ãƒ³ãƒˆã§è¡Œã†ã®ã§ã€ãã“ã¾ã§ç«¶åˆã—ãªã„
                                // this.tempSettings.timeLimitMin = Math.floor(this.settings.timeLimit / 60);
                                // this.tempSettings.showMaster = this.settings.showMaster;
                                // this.tempSettings.likePoints = this.settings.likePoints;
                            }
                        }

                        // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹å¤‰åŒ–æ¤œçŸ¥
                        if (this.gamePhase !== data.status) {
                            const oldPhase = this.gamePhase;
                            this.gamePhase = data.status;

                            if (this.gamePhase === 'FINISHED') {
                                this.viewState = 'FINISHED';
                            } else if (this.gamePhase === 'WAITING') {
                                this.viewState = 'WAITING';
                                // ãƒ­ãƒ“ãƒ¼ã«æˆ»ã£ãŸã‚‰tempSettingsã‚‚åˆæœŸåŒ–
                                if (this.settings) {
                                    this.tempSettings.timeLimitMin = Math.floor(this.settings.timeLimit / 60);
                                    this.tempSettings.showMaster = this.settings.showMaster;
                                    this.tempSettings.showMaster = this.settings.showMaster;
                                    this.tempSettings.likePoints = this.settings.likePoints;
                                    this.tempSettings.everyonePlays = this.settings.everyonePlays;
                                    this.tempSettings.handSizeFive = this.settings.handSizeFive || 10;
                                    this.tempSettings.handSizeSeven = this.settings.handSizeSeven || 5;
                                }
                            } else {
                                this.viewState = 'GAME';
                            }

                            if (this.gamePhase === 'WRITING') {
                                this.myDraft = { top: null, middle: null, bottom: null };
                                this.isResultAnimationDone = false;
                                this.tempRankState = {};
                                this.isSpecialEffectDone = false; // ãƒ•ãƒ©ã‚°åˆæœŸåŒ–
                                // ã‚¿ã‚¤ãƒãƒ¼é–‹å§‹
                                this.startTimer();
                            } else if (this.gamePhase === 'JUDGING') {
                                this.stopTimer();
                                // æ¼”å‡ºåˆ¤å®š
                                // å°‘ã—å¾…ã£ã¦ã‹ã‚‰ä¿³å¥ãƒªã‚¹ãƒˆã‚’ç¢ºèªï¼ˆåŒæœŸã‚ºãƒ¬å¯¾ç­–ï¼‰
                                setTimeout(() => {
                                    if (!this.isSpecialEffectDone) {
                                        this.processSpecialEffects();
                                    }
                                }, 1000);
                            } else {
                                this.stopTimer();
                            }

                            if (this.gamePhase === 'RESULT') {
                                this.playResultAnimation();
                            }
                        } else {
                            // ãƒ•ã‚§ãƒ¼ã‚ºãŒå¤‰ã‚ã‚‰ãªãã¦ã‚‚æ™‚åˆ»åŒæœŸãªã©ã§ã‚¿ã‚¤ãƒãƒ¼èª¿æ•´ãŒå¿…è¦ã‹ã‚‚
                            if (this.gamePhase === 'WRITING') {
                                this.startTimer();
                            }
                        }
                    }, (error) => {
                        console.error('Room listener error:', error);
                        this.connectionStatus = 'offline';
                        this.lastError = error;
                    });

                    // ä¿³å¥ç›£è¦–
                    const haikusRef = collection(db, "rooms", this.roomId, "haikus");
                    this.unsubHaikus = onSnapshot(haikusRef, (snapshot) => {
                        const allHaikus = snapshot.docs.map(d => ({ id: d.id, ...d.data() }));

                        // å…¨ä¿³å¥ã‚’ä¿æŒï¼ˆMVPç”¨ï¼‰
                        this.allGameHaikus = allHaikus;

                        this.currentHaikus = allHaikus.filter(h =>
                            h.gameCount === this.gameCount &&
                            h.round === this.roundCount
                        );

                        // è‡ªå‹•é€²è¡Œãƒã‚§ãƒƒã‚¯
                        const isMasterNPC = this.masterUid && this.masterUid.startsWith('npc-');
                        if ((this.isMeMaster || isMasterNPC) && this.gamePhase === 'WRITING') {
                            const writers = this.settings.everyonePlays
                                ? this.players
                                : this.players.filter(p => p.uid !== this.masterUid);
                            if (writers.length > 0 && this.currentHaikus.length >= writers.length) {
                                updateDoc(doc(db, "rooms", this.roomId), { status: 'JUDGING' });
                            }
                        }
                    }, (error) => {
                        console.error('Haikus listener error:', error);
                    });
                },

                processSpecialEffects() {
                    const specials = this.currentHaikus.filter(h => h.isSpecial);
                    if (specials.length > 0) {
                        // ãƒ©ãƒ³ãƒ€ãƒ ã‚­ãƒ¼é †ãªã©ã§ã‚½ãƒ¼ãƒˆæ¸ˆã¿ã§ã‚ã‚‹ã“ã¨ã‚’æœŸå¾…ã™ã‚‹ãªã‚‰ currentHaikus ã®é †åºã«å¾“ã†
                        // æ¼”å‡ºç”¨ã«ã‚­ãƒ¥ãƒ¼ã«å…¥ã‚Œã‚‹
                        this.specialEffectQueue = [...specials];
                        this.isSpecialEffectDone = true; // å†ç”Ÿé–‹å§‹ãƒ•ãƒ©ã‚°
                        this.playNextSpecialEffect();
                    }
                },

                playNextSpecialEffect() {
                    if (this.specialEffectQueue.length === 0) {
                        this.showSpecialEffectOverlay = false;
                        this.specialEffectHaiku = null;
                        return;
                    }

                    const next = this.specialEffectQueue.shift();
                    this.specialEffectHaiku = next;
                    this.showSpecialEffectOverlay = true;

                    // 5ç§’å¾Œã«æ¬¡ã¸
                    setTimeout(() => {
                        this.showSpecialEffectOverlay = false; // ä¸€æ—¦æ¶ˆã™ï¼ˆãƒ•ã‚§ãƒ¼ãƒ‰ã‚¢ã‚¦ãƒˆç”¨ï¼‰

                        // å°‘ã—é–“éš”ã‚’ç©ºã‘ã¦æ¬¡
                        if (this.specialEffectQueue.length > 0) {
                            setTimeout(() => {
                                this.playNextSpecialEffect();
                            }, 500); // 0.5ç§’é–“éš”
                        } else {
                            this.specialEffectHaiku = null;
                        }
                    }, 5000);
                },

                // --- UIè¡¨ç¤ºç”¨ã‚¯ãƒ©ã‚¹ ---
                getCardClass(card) {
                    return {
                        oni: card.isOni,
                        free: card.isFree,
                        selected: this.isCardSelected(card)
                    };
                },
                getSlotClass(card) {
                    if (!card) return {};
                    return { filled: true, oni: card.isOni, free: card.isFree };
                },

                // --- è© å”±ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ---
                isCardSelected(card) {
                    const d = this.myDraft;
                    return (d.top && d.top.id === card.id) ||
                        (d.middle && d.middle.id === card.id) ||
                        (d.bottom && d.bottom.id === card.id);
                },
                selectFive(card) {
                    if (!this.myDraft.top) this.myDraft.top = card;
                    else if (!this.myDraft.bottom) this.myDraft.bottom = card;
                    else this.myDraft.top = card;
                },
                selectSeven(card) {
                    this.myDraft.middle = card;
                },
                removePart(part) {
                    this.myDraft[part] = null;
                },

                // --- è‡ªç”±è¨˜å…¥è¿½åŠ  ---
                async addFreeCard() {
                    if (!this.freeInputText) return;

                    const newCard = {
                        id: 'free-' + Date.now(),
                        text: this.freeInputText,
                        type: this.freeInputType,
                        score: 1,
                        isOni: false,
                        isFree: true
                    };

                    const myIdx = this.players.findIndex(p => p.uid === this.myUid);
                    if (myIdx === -1) return;

                    const updatedPlayers = [...this.players];
                    const myHand = { ...updatedPlayers[myIdx].hand };

                    if (this.freeInputType === 5) {
                        myHand.fives = [newCard, ...myHand.fives];
                    } else {
                        myHand.sevens = [newCard, ...myHand.sevens];
                    }

                    updatedPlayers[myIdx].hand = myHand;

                    await updateDoc(doc(db, "rooms", this.roomId), { players: updatedPlayers });
                    this.freeInputText = '';
                },

                // --- ãƒªã‚»ãƒƒãƒˆ ---
                async resetDraft() {
                    let needDbUpdate = false;
                    const myIdx = this.players.findIndex(p => p.uid === this.myUid);
                    if (myIdx === -1) {
                        this.myDraft = { top: null, middle: null, bottom: null };
                        return;
                    }

                    let updatedPlayers = [...this.players];
                    let myHand = { ...updatedPlayers[myIdx].hand };

                    // æ‰‹æœ­å†…ã®è‡ªç”±è¨˜å…¥ã‚«ãƒ¼ãƒ‰ã‚’å…¨ã¦å‰Šé™¤
                    const originalFivesCount = myHand.fives.length;
                    const originalSevensCount = myHand.sevens.length;

                    myHand.fives = myHand.fives.filter(c => !c.isFree);
                    myHand.sevens = myHand.sevens.filter(c => !c.isFree);

                    if (myHand.fives.length !== originalFivesCount || myHand.sevens.length !== originalSevensCount) {
                        needDbUpdate = true;
                    }

                    if (needDbUpdate) {
                        updatedPlayers[myIdx].hand = myHand;
                        await updateDoc(doc(db, "rooms", this.roomId), { players: updatedPlayers });
                    }

                    this.myDraft = { top: null, middle: null, bottom: null };
                },

                async submitHaiku() {
                    if (!this.myDraft.top) return;
                    const cardScore = this.myDraft.top.score + this.myDraft.middle.score + this.myDraft.bottom.score;

                    // é‡è¤‡æå‡ºé˜²æ­¢ã®ãŸã‚ã€ãƒ¦ãƒ¼ã‚¶ãƒ¼IDã¨ãƒ©ã‚¦ãƒ³ãƒ‰æƒ…å ±ã‚’ã‚­ãƒ¼ã«ã—ãŸIDã‚’ç”Ÿæˆ
                    const haikuId = `${this.gameCount}_${this.roundCount}_${this.myUid}`;

                    const isSpecial = this.useSpecialEffect && !this.hasMySpecialEffectUsed;

                    await setDoc(doc(db, "rooms", this.roomId, "haikus", haikuId), {
                        userId: this.myUid,
                        top: this.myDraft.top,
                        middle: this.myDraft.middle,
                        bottom: this.myDraft.bottom,
                        gameCount: this.gameCount,
                        round: this.roundCount,
                        rank: 0,
                        likes: [],
                        cardScore: cardScore,
                        bonusScore: 0,
                        totalScore: 0,
                        randomSortKey: Math.random(),
                        isSpecial: isSpecial // æ¼”å‡ºãƒ•ãƒ©ã‚°
                    });

                    // æ¼”å‡ºã‚’ä½¿ç”¨ã—ãŸå ´åˆã¯ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼æƒ…å ±ã‚’æ›´æ–°
                    if (isSpecial) {
                        const myIdx = this.players.findIndex(p => p.uid === this.myUid);
                        if (myIdx !== -1) {
                            const updatedPlayers = [...this.players];
                            updatedPlayers[myIdx].specialEffectUsed = true;
                            await updateDoc(doc(db, "rooms", this.roomId), { players: updatedPlayers });
                        }
                    }

                    // æå‡ºã—ãŸã‚‰ãƒ•ãƒ©ã‚°æˆ»ã™
                    this.useSpecialEffect = false;
                },

                // --- å¼·åˆ¶é€²è¡Œ ---
                async forceAllSubmit() {
                    const batch = writeBatch(db);
                    const haikusRef = collection(db, "rooms", this.roomId, "haikus");

                    const unsubmittedPlayers = this.players.filter(p => {
                        if (!this.settings.everyonePlays && p.uid === this.masterUid) return false;
                        return !this.currentHaikus.find(h => h.userId === p.uid);
                    });

                    unsubmittedPlayers.forEach(p => {
                        const topCands = p.hand.fives.filter(c => !c.isFree);
                        const top = topCands[Math.floor(Math.random() * topCands.length)];

                        const midCands = p.hand.sevens.filter(c => !c.isFree);
                        const middle = midCands[Math.floor(Math.random() * midCands.length)];

                        const botCands = topCands.filter(c => c.id !== top.id);
                        const bottom = botCands.length > 0 ? botCands[Math.floor(Math.random() * botCands.length)] : top;

                        const cardScore = top.score + middle.score + bottom.score;

                        const haikuId = `${this.gameCount}_${this.roundCount}_${p.uid}`;
                        const newDocRef = doc(haikusRef, haikuId);
                        batch.set(newDocRef, {
                            userId: p.uid,
                            top, middle, bottom,
                            gameCount: this.gameCount,
                            round: this.roundCount,
                            rank: 0, likes: [], cardScore, bonusScore: 0, totalScore: 0,
                            randomSortKey: Math.random()
                        });
                    });

                    await batch.commit();
                    setTimeout(() => {
                        updateDoc(doc(db, "rooms", this.roomId), { status: 'JUDGING' });
                    }, 500);
                },

                // --- é¸è©•ã‚¢ã‚¯ã‚·ãƒ§ãƒ³ ---
                setRank(haiku, rank) {
                    for (const [hid, r] of Object.entries(this.tempRankState)) {
                        if (r === rank) delete this.tempRankState[hid];
                    }
                    this.tempRankState[haiku.id] = rank;
                },

                async toggleLike(haiku) {
                    const haikuRef = doc(db, "rooms", this.roomId, "haikus", haiku.id);
                    const isLiked = haiku.likes && haiku.likes.includes(this.myUid);

                    if (isLiked) {
                        const newLikes = haiku.likes.filter(uid => uid !== this.myUid);
                        await updateDoc(haikuRef, { likes: newLikes });
                    } else {
                        await updateDoc(haikuRef, { likes: arrayUnion(this.myUid) });
                    }
                },

                async finalizeJudging() {
                    const batch = writeBatch(db);
                    const roomRef = doc(db, "rooms", this.roomId);

                    const scoreUpdates = {};
                    const likeUpdates = {};
                    this.players.forEach(p => { scoreUpdates[p.uid] = 0; likeUpdates[p.uid] = 0; });

                    for (const h of this.currentHaikus) {
                        const rank = this.tempRankState[h.id] || 0;

                        let rankScore = 0;
                        if (!this.settings.everyonePlays) {
                            if (rank === 1) rankScore = 100;
                            else if (rank === 2) rankScore = 60;
                            else if (rank === 3) rankScore = 20;
                        }

                        const likeCount = h.likes ? h.likes.length : 0;
                        const likeScore = likeCount * this.settings.likePoints;
                        const bonusScore = rankScore + likeScore;
                        const totalScore = (h.cardScore || 0) + bonusScore;

                        const hRef = doc(db, "rooms", this.roomId, "haikus", h.id);
                        batch.update(hRef, { rank, bonusScore, totalScore });

                        if (scoreUpdates[h.userId] !== undefined) {
                            scoreUpdates[h.userId] += totalScore;
                            likeUpdates[h.userId] += likeCount;
                        }
                    }

                    const newPlayers = this.players.map(p => {
                        return {
                            ...p,
                            score: p.score + (scoreUpdates[p.uid] || 0),
                            totalLikes: (p.totalLikes || 0) + (likeUpdates[p.uid] || 0)
                        };
                    });

                    batch.update(roomRef, { players: newPlayers, status: 'RESULT' });

                    await batch.commit();
                },

                // å¼·åˆ¶é€²è¡Œï¼ˆã„ã„ã­æœªå®Œäº†ã§ã‚‚çµæœç™ºè¡¨ã¸é€²ã‚€ï¼‰
                async forceFinalize() {
                    const batch = writeBatch(db);
                    const roomRef = doc(db, "rooms", this.roomId);

                    const scoreUpdates = {};
                    const likeUpdates = {};
                    this.players.forEach(p => { scoreUpdates[p.uid] = 0; likeUpdates[p.uid] = 0; });

                    for (const h of this.currentHaikus) {
                        const rank = this.tempRankState[h.id] || 0;

                        let rankScore = 0;
                        if (rank === 1) rankScore = 100;
                        else if (rank === 2) rankScore = 60;
                        else if (rank === 3) rankScore = 20;

                        const likeCount = h.likes ? h.likes.length : 0;
                        const likeScore = likeCount * this.settings.likePoints;
                        const bonusScore = rankScore + likeScore;
                        const totalScore = (h.cardScore || 0) + bonusScore;

                        const hRef = doc(db, "rooms", this.roomId, "haikus", h.id);
                        batch.update(hRef, { rank, bonusScore, totalScore });

                        if (scoreUpdates[h.userId] !== undefined) {
                            scoreUpdates[h.userId] += totalScore;
                            likeUpdates[h.userId] += likeCount;
                        }
                    }

                    const newPlayers = this.players.map(p => {
                        return {
                            ...p,
                            score: p.score + (scoreUpdates[p.uid] || 0),
                            totalLikes: (p.totalLikes || 0) + (likeUpdates[p.uid] || 0)
                        };
                    });

                    batch.update(roomRef, { players: newPlayers, status: 'RESULT' });

                    await batch.commit();
                },

                getHaikuCardScore(haiku) {
                    return haiku.top.score + haiku.middle.score + haiku.bottom.score;
                },
                getRankScore(rank) {
                    if (rank === 1) return 100;
                    if (rank === 2) return 60;
                    if (rank === 3) return 20;
                    return 0;
                },

                playResultAnimation() {
                    let count = 0;
                    const total = this.currentHaikus.length || 0;
                    this.visibleResultCount = 0;
                    const interval = setInterval(() => {
                        count++;
                        this.visibleResultCount = count;
                        if (count >= total) {
                            clearInterval(interval);
                            this.isResultAnimationDone = true;
                        }
                    }, 1500);
                },

                // --- ã‚²ãƒ¼ãƒ é€²è¡Œãƒ»è¨­å®š ---
                async saveSettings() {
                    if (!this.isMeMaster) return;
                    // tempSettings -> settings -> DB
                    const newSettings = {
                        timeLimit: this.tempSettings.timeLimitMin * 60,
                        showMaster: this.tempSettings.showMaster,
                        showScore: this.tempSettings.showScore,
                        likePoints: this.tempSettings.likePoints,
                        everyonePlays: this.tempSettings.everyonePlays,
                        handSizeFive: this.tempSettings.handSizeFive,
                        handSizeSeven: this.tempSettings.handSizeSeven
                    };
                    await updateDoc(doc(db, "rooms", this.roomId), { settings: newSettings });
                },

                async startGame() {
                    // Start Gameãƒœã‚¿ãƒ³
                    try {
                        // é–‹å§‹æ™‚ã«è¨­å®šã‚’ä¿å­˜ã—ã¦ç¢ºå®Ÿã«ã™ã‚‹
                        await this.saveSettings();

                        console.log('Starting game for room:', this.roomId);

                        // è¦ªã‚’ãƒ©ãƒ³ãƒ€ãƒ ã«é¸å‡º
                        const randomIdx = Math.floor(Math.random() * this.players.length);
                        const nextMasterUid = this.players[randomIdx].uid;

                        // è¨­å®šã«åˆã‚ã›ã¦æ‰‹æœ­ã‚’é…ã‚Šç›´ã™
                        const refreshedPlayers = this.players.map(p => {
                            return {
                                ...p,
                                hand: generateHand(
                                    this.tempSettings.handSizeFive,
                                    this.tempSettings.handSizeSeven
                                )
                            };
                        });

                        await updateDoc(doc(db, "rooms", this.roomId), {
                            status: 'WRITING',
                            roundStartTime: Date.now(),
                            masterUid: nextMasterUid,
                            masterHistory: [nextMasterUid],
                            players: refreshedPlayers
                        });
                        console.log('Game status updated to WRITING');
                    } catch (e) {
                        console.error('Error starting game:', e);
                        alert('ã‚²ãƒ¼ãƒ é–‹å§‹ã‚¨ãƒ©ãƒ¼: ' + e.message);
                    }
                },

                startTimer() {
                    if (this.timerInterval) clearInterval(this.timerInterval);
                    this.updateTime();
                    this.timerInterval = setInterval(() => {
                        this.updateTime();
                    }, 1000);
                },
                stopTimer() {
                    if (this.timerInterval) clearInterval(this.timerInterval);
                    this.timerInterval = null;
                    this.timeLeft = 0;
                },
                updateTime() {
                    if (!this.roundStartTime || this.gamePhase !== 'WRITING') {
                        this.timeLeft = 0;
                        return;
                    }
                    const elapsed = (Date.now() - this.roundStartTime) / 1000;
                    const limit = this.settings.timeLimit;
                    const remain = limit - elapsed;

                    if (remain <= 0) {
                        this.timeLeft = 0;
                        // è¦ªã§ã‚ã‚Œã°å¼·åˆ¶å®Ÿè¡Œ
                        if (this.isMeMaster && this.gamePhase === 'WRITING') {
                            // é€£æ‰“é˜²æ­¢ã®ãŸã‚ã€ã™ã§ã«å‡¦ç†ä¸­ãªã‚‰ã‚¹ã‚­ãƒƒãƒ—ã—ãŸã„ãŒ...
                            // forceAllSubmitå†…ã§batchå‡¦ç†ã™ã‚‹ã®ã§ã‚ã‚‹ç¨‹åº¦å®‰å…¨ã€‚
                            // ãŸã ã—çŸ­æ™‚é–“ã«ä½•åº¦ã‚‚å‘¼ã°ã‚Œã‚‹ã¨å›°ã‚‹
                            this.forceAllSubmit();
                        }
                    } else {
                        this.timeLeft = Math.floor(remain);
                    }
                },

                async nextRound() {
                    if (this.roundCount >= this.players.length) {
                        // ã‚²ãƒ¼ãƒ çµ‚äº†æ™‚ã€å„ªå‹è€…ã®ã‚«ã‚¦ãƒ³ãƒˆã‚’åŠ ç®—
                        const sorted = [...this.players].sort((a, b) => b.score - a.score);
                        const topScore = sorted.length > 0 ? sorted[0].score : -999;

                        // å…¨å“¡ã®winCountã‚’æ›´æ–°
                        const updatedPlayers = this.players.map(p => {
                            if (p.score === topScore && topScore > 0) { // 0ç‚¹ã®å ´åˆã¯å„ªå‹ã¨ã¿ãªã•ãªã„ç­‰ã¯å¥½ã¿ã ãŒã€ã“ã“ã§ã¯å˜ç´”ã«æœ€é«˜å¾—ç‚¹
                                return { ...p, winCount: (p.winCount || 0) + 1 };
                            }
                            return p;
                        });

                        await updateDoc(doc(db, "rooms", this.roomId), {
                            status: 'FINISHED',
                            players: updatedPlayers
                        });
                    } else {
                        // æ¬¡ã®è¦ªã‚’æ±ºå®šï¼ˆé †ç•ªã«å›ã™ï¼‰
                        // â€»å˜ç´”ã« roundCount % length ã ã¨ã€ã‚²ãƒ¼ãƒ 2å›ç›®ä»¥é™ã«ãŠã‹ã—ããªã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ãŸã‚ã€
                        // ã€Œã‚²ãƒ¼ãƒ é–‹å§‹æ™‚ã®è¦ªã€ã‚’åŸºæº–ã«ã‚·ãƒ•ãƒˆã•ã›ã‚‹ã‹ã€å˜ã«ã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ã‚’å›ã™ã€‚
                        // ä»Šå›ã¯ã‚·ãƒ³ãƒ—ãƒ«ã« (ç¾åœ¨ã®è¦ªã‚¤ãƒ³ãƒ‡ãƒƒã‚¯ã‚¹ + 1) % äººæ•° ã§è¨ˆç®—ã™ã‚‹ã€‚

                        const currentMasterIdx = this.players.findIndex(p => p.uid === this.masterUid);
                        let nextMasterIdx = 0;
                        if (currentMasterIdx !== -1) {
                            nextMasterIdx = (currentMasterIdx + 1) % this.players.length;
                        }

                        const nextMasterUid = this.players[nextMasterIdx].uid;

                        const refreshedPlayers = this.players.map(p => {
                            return { ...p, hand: generateHand(this.settings.handSizeFive, this.settings.handSizeSeven) };
                        });

                        const newHistory = [...this.masterHistory];
                        if (!newHistory.includes(nextMasterUid)) newHistory.push(nextMasterUid);

                        await updateDoc(doc(db, "rooms", this.roomId), {
                            roundCount: increment(1),
                            masterUid: nextMasterUid,
                            masterHistory: newHistory,
                            status: 'WRITING',
                            players: refreshedPlayers,
                            roundStartTime: Date.now()
                        });
                    }
                },

                async startNextGame() {
                    // æ¬¡ã®ã‚²ãƒ¼ãƒ ã®è¨­å®šã®ãŸã‚ãƒ­ãƒ“ãƒ¼ã«æˆ»ã‚‹
                    const resetPlayers = this.players.map(p => ({
                        ...p,
                        score: 0,
                        totalLikes: 0,
                        // winCountã¯ç¶­æŒã•ã‚Œã‚‹(pã«å«ã¾ã‚Œã‚‹ãŸã‚)
                        hand: generateHand(this.settings.handSizeFive, this.settings.handSizeSeven)
                    }));
                    const firstMaster = resetPlayers[0].uid;

                    await updateDoc(doc(db, "rooms", this.roomId), {
                        players: resetPlayers,
                        gameCount: increment(1),
                        roundCount: 1,
                        masterUid: firstMaster,
                        masterHistory: [firstMaster],
                        status: 'WAITING', // ãƒ­ãƒ“ãƒ¼ã¸
                        roundStartTime: null
                    });
                },

                async leaveRoom() {
                    // Firestoreã‹ã‚‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼å‰Šé™¤å‡¦ç†
                    if (this.roomId && this.myUid) {
                        try {
                            const roomRef = doc(db, "rooms", this.roomId);
                            const roomSnap = await getDoc(roomRef);
                            if (roomSnap.exists()) {
                                const data = roomSnap.data();
                                // è‡ªåˆ†ã®UIDã‚’é™¤å¤–ã—ãŸãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ãƒªã‚¹ãƒˆã‚’ä½œæˆ
                                const newPlayers = data.players.filter(p => p.uid !== this.myUid);
                                await updateDoc(roomRef, { players: newPlayers });
                            }
                        } catch (e) {
                            console.error('Leave room error:', e);
                        }
                    }

                    if (this.unsubRoom) this.unsubRoom();
                    if (this.unsubHaikus) this.unsubHaikus();
                    this.clearSession();
                    this.viewState = 'LOBBY';
                    this.roomId = '';
                    this.currentHaikus = [];
                },

                // ãƒ«ãƒ¼ãƒ æƒ…å ±ã‚’å®Œå…¨ã«ãƒªã‚»ãƒƒãƒˆï¼ˆå‰Šé™¤ï¼‰
                async resetRoom() {
                    if (!this.roomId) {
                        this.errorMessage = 'ãƒ«ãƒ¼ãƒ ç•ªå·ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„';
                        return;
                    }

                    const confirmed = confirm(`ãƒ«ãƒ¼ãƒ  ${this.roomId} ã®æƒ…å ±ã‚’å®Œå…¨ã«å‰Šé™¤ã—ã¾ã™ã€‚ã‚ˆã‚ã—ã„ã§ã™ã‹ï¼Ÿ`);
                    if (!confirmed) return;

                    this.isLoading = true;
                    this.errorMessage = '';

                    try {
                        // ãƒªã‚¹ãƒŠãƒ¼ã‚’è§£é™¤
                        if (this.unsubRoom) this.unsubRoom();
                        if (this.unsubHaikus) this.unsubHaikus();

                        const roomRef = doc(db, "rooms", this.roomId);

                        // ã‚µãƒ–ã‚³ãƒ¬ã‚¯ã‚·ãƒ§ãƒ³ï¼ˆä¿³å¥ï¼‰ã‚’å‰Šé™¤
                        const haikusRef = collection(db, "rooms", this.roomId, "haikus");
                        const haikusSnapshot = await getDocs(haikusRef);
                        const batch = writeBatch(db);

                        haikusSnapshot.forEach((docSnap) => {
                            batch.delete(docSnap.ref);
                        });

                        // ãƒ«ãƒ¼ãƒ ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆã‚’å‰Šé™¤
                        batch.delete(roomRef);

                        await batch.commit();

                        // ãƒ­ãƒ¼ã‚«ãƒ«çŠ¶æ…‹ã‚’ãƒªã‚»ãƒƒãƒˆ
                        this.clearSession();
                        this.viewState = 'LOBBY';
                        this.currentHaikus = [];
                        this.players = [];
                        this.masterHistory = [];
                        this.roundCount = 1;
                        this.gameCount = 1;
                        this.viewState = 'LOBBY';
                        this.currentHaikus = [];
                        this.players = [];
                        this.masterHistory = [];
                        this.roundCount = 1;
                        this.gameCount = 1;
                        this.gamePhase = 'WRITING';
                        this.stopTimer();

                        alert(`ãƒ«ãƒ¼ãƒ  ${this.roomId} ã‚’å‰Šé™¤ã—ã¾ã—ãŸã€‚`);
                        this.roomId = '';
                    } catch (e) {
                        console.error('Room reset error:', e);
                        this.errorMessage = 'ãƒªã‚»ãƒƒãƒˆã«å¤±æ•—ã—ã¾ã—ãŸ: ' + e.message;
                    } finally {
                        this.isLoading = false;
                    }
                },

                getMasterName() {
                    const p = this.players.find(p => p.uid === this.masterUid);
                    return p ? p.name : 'ä¸æ˜';
                },
                getPlayerName(uid) {
                    const p = this.players.find(p => p.uid === uid);
                    return p ? p.name : 'ä¸æ˜';
                },
                hasBeenMaster(uid) {
                    return this.masterHistory.includes(uid);
                },

                // --- ãƒ‡ãƒãƒƒã‚°ç”¨æ©Ÿèƒ½ ---
                // --- ãƒ‡ãƒãƒƒã‚°ç”¨æ©Ÿèƒ½ ---
                switchPlayer(uid) {
                    this.myUid = uid;
                    const p = this.players.find(x => x.uid === uid);
                    if (p) this.myPlayerName = p.name;
                },
                async add3NPCs() {
                    if (!this.roomId) return;
                    const npcNames = ['NPCä¸€èŒ¶', 'NPCè•ªæ‘', 'NPCå­è¦'];
                    const newPlayers = [];
                    for (let i = 0; i < 3; i++) {
                        const npcId = 'npc-' + Math.random().toString(36).substr(2, 5);
                        newPlayers.push({
                            uid: npcId,
                            name: npcNames[i],
                            score: 0,
                            totalLikes: 0,
                            winCount: 0,
                            hand: generateHand(this.settings.handSizeFive, this.settings.handSizeSeven)
                        });
                    }
                    await updateDoc(doc(db, "rooms", this.roomId), { players: arrayUnion(...newPlayers) });
                },

                async npcMasterJudge() {
                    const roomRef = doc(db, "rooms", this.roomId);
                    const candidates = [...this.currentHaikus].sort(() => 0.5 - Math.random());

                    const tempRanks = {};
                    candidates.forEach((h, i) => {
                        if (i === 0) tempRanks[h.id] = 1;
                        else if (i === 1) tempRanks[h.id] = 2;
                        else if (i === 2) tempRanks[h.id] = 3;
                    });

                    const batch = writeBatch(db);
                    const scoreUpdates = {};
                    const likeUpdates = {};
                    this.players.forEach(p => { scoreUpdates[p.uid] = 0; likeUpdates[p.uid] = 0; });

                    for (const h of this.currentHaikus) {
                        const rank = tempRanks[h.id] || 0;
                        let rankScore = 0;
                        if (rank === 1) rankScore = 100;
                        else if (rank === 2) rankScore = 60;
                        else if (rank === 3) rankScore = 20;

                        const likeCount = h.likes ? h.likes.length : 0;
                        const likeScore = likeCount * (this.settings.likePoints || 10);
                        const bonusScore = rankScore + likeScore;
                        const totalScore = (h.cardScore || 0) + bonusScore;

                        const hRef = doc(db, "rooms", this.roomId, "haikus", h.id);
                        batch.update(hRef, { rank, bonusScore, totalScore });

                        if (scoreUpdates[h.userId] !== undefined) {
                            scoreUpdates[h.userId] += totalScore;
                            likeUpdates[h.userId] += likeCount;
                        }
                    }

                    const newPlayers = this.players.map(p => {
                        return {
                            ...p,
                            score: p.score + (scoreUpdates[p.uid] || 0),
                            totalLikes: (p.totalLikes || 0) + (likeUpdates[p.uid] || 0)
                        };
                    });

                    batch.update(roomRef, { players: newPlayers, status: 'RESULT' });
                    await batch.commit();
                },

                async old_addNPC() {
                    if (!this.roomId) return;
                    const npcId = 'npc-' + Math.random().toString(36).substr(2, 5);
                    const npcNames = ['ä¸€èŒ¶', 'è•ªæ‘', 'å­è¦', 'è™šå­', 'æ™¶å­', 'å•„æœ¨', 'ä¸‡è‘‰'];
                    const name = 'NPC ' + npcNames[Math.floor(Math.random() * npcNames.length)];

                    const newPlayer = {
                        uid: npcId,
                        name: name,
                        score: 0,
                        totalLikes: 0,
                        winCount: 0,
                        hand: generateHand()
                    };

                    await updateDoc(doc(db, "rooms", this.roomId), {
                        players: arrayUnion(newPlayer)
                    });
                },

                async npcSubmitAll() {
                    const batch = writeBatch(db);
                    const haikusRef = collection(db, "rooms", this.roomId, "haikus");

                    // æœªæå‡ºã®NPCã‚’æ¢ã™
                    const unsubmittedNPCs = this.players.filter(p => {
                        return p.uid.startsWith('npc-') &&
                            p.uid !== this.masterUid &&
                            !this.currentHaikus.find(h => h.userId === p.uid);
                    });

                    if (unsubmittedNPCs.length === 0) {
                        alert('æå‡ºå¯èƒ½ãªNPCã¯ã„ã¾ã›ã‚“');
                        return;
                    }

                    unsubmittedNPCs.forEach(p => {
                        // æ‰‹æœ­ã‹ã‚‰ãƒ©ãƒ³ãƒ€ãƒ ã«é¸ã¶
                        const top = p.hand.fives[Math.floor(Math.random() * p.hand.fives.length)];
                        const middle = p.hand.sevens[Math.floor(Math.random() * p.hand.sevens.length)];
                        // bottomã¯topã¨è¢«ã‚‰ãªã„ã‚ˆã†ã«
                        let bottomCands = p.hand.fives.filter(c => c.id !== top.id);
                        if (bottomCands.length === 0) bottomCands = [top];
                        const bottom = bottomCands[Math.floor(Math.random() * bottomCands.length)];

                        const cardScore = top.score + middle.score + bottom.score;

                        const newDocRef = doc(haikusRef);
                        batch.set(newDocRef, {
                            userId: p.uid,
                            top, middle, bottom,
                            gameCount: this.gameCount,
                            round: this.roundCount,
                            rank: 0, likes: [], cardScore, bonusScore: 0, totalScore: 0,
                            randomSortKey: Math.random()
                        });
                    });

                    await batch.commit();
                },

                async addToHallOfFame() {
                    if (!this.topLikedHaikus || this.topLikedHaikus.length === 0) {
                        alert("MVPä¿³å¥ãŒãªã„ãŸã‚ç™»éŒ²ã§ãã¾ã›ã‚“");
                        return;
                    }
                    if (!confirm("ç¾åœ¨ã®çµæœã‚’æ®¿å ‚å…¥ã‚Šã«ç™»éŒ²ã—ã¾ã™ã‹ï¼Ÿ")) return;

                    try {
                        await addDoc(collection(db, "hallOfFame"), {
                            createdAt: Date.now(),
                            roomId: this.roomId,
                            players: this.sortedPlayers, // æœ€çµ‚é †ä½
                            mvpHaikus: this.topLikedHaikus,
                            gameCount: this.gameCount
                        });
                        alert("æ®¿å ‚å…¥ã‚Šã«ç™»éŒ²ã—ã¾ã—ãŸï¼");
                    } catch (e) {
                        console.error("Hall of fame error:", e);
                        alert("ç™»éŒ²ã«å¤±æ•—ã—ã¾ã—ãŸ: " + e.message);
                    }
                },

                async openHallOfFame() {
                    this.isLoading = true;
                    try {
                        const q = window.query || ((ref, opts) => ref); // queryé–¢æ•°ãŒimportã•ã‚Œã¦ã„ãªã„å ´åˆã®å¯¾ç­–ãŒå¿…è¦ã ãŒã€ä»Šå›ã¯CDNã‹ã‚‰å…¨éƒ¨å–ã£ã¦ã‚‹ã¯ãšã€‚
                        // firebase-firestore.jsã®importã«query, orderBy, limitã‚’è¿½åŠ ã™ã‚‹å¿…è¦ãŒã‚ã‚‹ã‹ã‚‚ã€‚
                        // å…ˆã»ã©ã®importæ–‡ã‚’ç¢ºèªã™ã‚‹ã¨ã€query, orderBy, limit ãŒè¶³ã‚Šãªã„å¯èƒ½æ€§ãŒã‚ã‚‹ã€‚
                        // ã“ã“ã§ã¯ã€ä¸€æ—¦å…¨ä»¶å–å¾—ã—ã¦JSã§ã‚½ãƒ¼ãƒˆã™ã‚‹ï¼ˆä»¶æ•°ãŒå°‘ãªã‘ã‚Œã°å•é¡Œãªã„ï¼‰

                        const snap = await getDocs(collection(db, "hallOfFame"));
                        const list = snap.docs.map(d => ({ id: d.id, ...d.data() }));

                        // æ—¥ä»˜é™é †
                        list.sort((a, b) => b.createdAt - a.createdAt);

                        this.hallOfFameList = list;
                        this.viewState = 'HALL_OF_FAME';
                    } catch (e) {
                        console.error(e);
                        alert("èª­ã¿è¾¼ã¿å¤±æ•—: " + e.message);
                    } finally {
                        this.isLoading = false;
                    }
                },

                closeHallOfFame() {
                    this.viewState = 'LOBBY';
                    this.hallOfFameList = [];
                },

                async resetHallOfFame() {
                    const password = prompt("æ®¿å ‚å…¥ã‚Šã‚’ãƒªã‚»ãƒƒãƒˆã™ã‚‹ãŸã‚ã®ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›ã—ã¦ãã ã•ã„");
                    if (password !== "1111") {
                        alert("ãƒ‘ã‚¹ãƒ¯ãƒ¼ãƒ‰ãŒé•ã„ã¾ã™");
                        return;
                    }

                    if (!confirm("æœ¬å½“ã«å…¨ã¦ã®æ®¿å ‚å…¥ã‚Šãƒ‡ãƒ¼ã‚¿ã‚’å‰Šé™¤ã—ã¾ã™ã‹ï¼Ÿ\nã“ã®æ“ä½œã¯å–ã‚Šæ¶ˆã›ã¾ã›ã‚“ã€‚")) return;

                    this.isLoading = true;
                    try {
                        const batch = writeBatch(db);
                        this.hallOfFameList.forEach(record => {
                            const ref = doc(db, "hallOfFame", record.id);
                            batch.delete(ref);
                        });
                        await batch.commit();

                        this.hallOfFameList = [];
                        alert("æ®¿å ‚å…¥ã‚Šãƒ‡ãƒ¼ã‚¿ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ");
                    } catch (e) {
                        console.error(e);
                        alert("ãƒªã‚»ãƒƒãƒˆå¤±æ•—: " + e.message);
                    } finally {
                        this.isLoading = false;
                    }
                },

                formatDate(ts) {
                    if (!ts) return '-';
                    const d = new Date(ts);
                    return d.toLocaleString('ja-JP', { month: 'short', day: 'numeric', hour: '2-digit', minute: '2-digit' });
                },

                // npcLikeAllãªã©ã®æ—¢å­˜ãƒ¡ã‚½ãƒƒãƒ‰ã®å¾Œã«ç¶šã
                async npcLikeAll() {
                    // ã„ã„ã­ã—ã¦ã„ãªã„NPCã‚’æ¢ã™
                    // è¦ªã§ã¯ãªã„NPC
                    const voterNPCs = this.players.filter(p => {
                        return p.uid.startsWith('npc-') && p.uid !== this.masterUid;
                    });

                    // è‡ªåˆ†ãŒã„ã„ã­æ¸ˆã¿ã®åˆ¤å®šãŒé›£ã—ã„ã®ã§ï¼ˆlikesé…åˆ—ã‚’è¦‹ã‚‹å¿…è¦ãŒã‚ã‚‹ï¼‰ã€
                    // ã“ã“ã§ã¯ã‚·ãƒ³ãƒ—ãƒ«ã«ã€Œã¾ã èª°ã«ã‚‚ã„ã„ã­ã—ã¦ã„ãªã„NPCã€ã«ãƒ©ãƒ³ãƒ€ãƒ ãªå¥ã¸ã„ã„ã­ã•ã›ã‚‹
                    // â€»å³å¯†ã«ã¯ã€Œè‡ªåˆ†ã®å¥ã«ã¯ã„ã„ã­ã§ããªã„ã€ãƒ«ãƒ¼ãƒ«ã‚‚é©ç”¨ã™ã¹ã

                    const updates = [];

                    for (const npc of voterNPCs) {
                        // npcãŒæ—¢ã«ã„ã„ã­ã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
                        const alreadyVoted = this.currentHaikus.some(h => h.likes && h.likes.includes(npc.uid));
                        if (alreadyVoted) continue;

                        // ã„ã„ã­å¯¾è±¡å€™è£œï¼ˆè‡ªåˆ†ã®å¥ä»¥å¤–ï¼‰
                        const candidates = this.currentHaikus.filter(h => h.userId !== npc.uid);
                        if (candidates.length === 0) continue;

                        const target = candidates[Math.floor(Math.random() * candidates.length)];

                        // æ›´æ–°ç”¨Mapã«è¿½åŠ 
                        // åŒã˜å¥ã«è¤‡æ•°ã®NPCãŒå…¥ã‚Œã‚‹å¯èƒ½æ€§ãŒã‚ã‚‹ã®ã§ã€transactionã‹ã€ã‚ã‚‹ã„ã¯ä¸€ã¤ãšã¤å‡¦ç†ã™ã‚‹
                        // ã“ã“ã§ã¯ç°¡å˜ã®ãŸã‚ä¸€ã¤ãšã¤updateDocã™ã‚‹
                        const haikuRef = doc(db, "rooms", this.roomId, "haikus", target.id);
                        await updateDoc(haikuRef, { likes: arrayUnion(npc.uid) });
                    }
                }
            }
        }).mount('#app');
    </script>
</body>

</html>